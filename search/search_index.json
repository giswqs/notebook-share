{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p>A website for sharing notebooks and markdown documents.</p>"},{"location":"AmericaView_2023/","title":"AmericaView 2023","text":"<p>Interactive Cloud Computing with Google Earth Engine and Geemap</p> <p>Introduction: This is a notebook prepared for the workshop at the AmericaView Annual Conference at Lafayette, Louisiana on March 13, 2023.</p> <p>Overview: Google Earth Engine (GEE) is a cloud computing platform with a multi-petabyte catalog of satellite imagery and geospatial datasets. It enables scientists, researchers, and developers to analyze and visualize changes on the Earth\u2019s surface. The geemap Python package provides GEE users with an intuitive interface to manipulate, analyze, and visualize geospatial big data interactively in a Jupyter-based environment. The topics will be covered in this workshop include: (1) introducing geemap and the Earth Engine Python API; (2) creating interactive maps; (3) searching GEE data catalog; (4) visualizing GEE datasets; (5) analyzing GEE datasets, and (6) exporting GEE datasets. More information about the geemap Python package can be found at https://geemap.org.</p> <p>Requirement: Please sign up for a Google Earth Engine account if you don\u2019t have one yet. No software installation is needed. You just need a browser with Internet access for this workshop.</p> In\u00a0[\u00a0]: Copied! <pre># %pip install geemap\n</pre> # %pip install geemap In\u00a0[\u00a0]: Copied! <pre>import ee\nimport geemap.foliumap as geemap\n</pre> import ee import geemap.foliumap as geemap In\u00a0[\u00a0]: Copied! <pre>geemap.ee_initialize()\n</pre> geemap.ee_initialize() In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map()\n</pre> Map = geemap.Map() <p>To display it in a Jupyter notebook, simply ask for the object representation:</p> In\u00a0[\u00a0]: Copied! <pre>Map\n</pre> Map <p>To customize the map, you can specify various keyword arguments, such as <code>center</code> ([lat, lon]), <code>zoom</code>, <code>width</code>, and <code>height</code>. The default <code>width</code> is <code>100%</code>, which takes up the entire cell width of the Jupyter notebook. The <code>height</code> argument accepts a number or a string. If a number is provided, it represents the height of the map in pixels. If a string is provided, the string must be in the format of a number followed by <code>px</code>, e.g., <code>600px</code>.</p> In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map(center=[40, -100], zoom=4, height=600)\nMap\n</pre> Map = geemap.Map(center=[40, -100], zoom=4, height=600) Map <p>To hide a control, set <code>control_name</code> to <code>False</code>, e.g., <code>draw_ctrl=False</code>.</p> In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map(data_ctrl=False, toolbar_ctrl=False, draw_ctrl=False)\nMap\n</pre> Map = geemap.Map(data_ctrl=False, toolbar_ctrl=False, draw_ctrl=False) Map In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map(basemap=\"HYBRID\")\nMap\n</pre> Map = geemap.Map(basemap=\"HYBRID\") Map <p>You can add as many basemaps as you like to the map. For example, the following code adds the <code>OpenTopoMap</code> basemap to the map above:</p> In\u00a0[\u00a0]: Copied! <pre>Map.add_basemap(\"OpenTopoMap\")\n</pre> Map.add_basemap(\"OpenTopoMap\") <p>Print out the first 10 basemaps:</p> In\u00a0[\u00a0]: Copied! <pre>basemaps = list(geemap.basemaps.keys())\nlen(geemap.basemaps)\n</pre> basemaps = list(geemap.basemaps.keys()) len(geemap.basemaps) In\u00a0[\u00a0]: Copied! <pre>basemaps[:10]\n</pre> basemaps[:10] In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map()\nMap.add_tile_layer(\n    url=\"https://mt1.google.com/vt/lyrs=p&amp;x={x}&amp;y={y}&amp;z={z}\",\n    name=\"Google Terrain\",\n    attribution=\"Google\",\n)\nMap\n</pre> Map = geemap.Map() Map.add_tile_layer(     url=\"https://mt1.google.com/vt/lyrs=p&amp;x={x}&amp;y={y}&amp;z={z}\",     name=\"Google Terrain\",     attribution=\"Google\", ) Map In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map(center=[40, -100], zoom=4)\nurl = \"https://www.mrlc.gov/geoserver/mrlc_display/NLCD_2019_Land_Cover_L48/wms?\"\nMap.add_wms_layer(\n    url=url,\n    layers=\"NLCD_2019_Land_Cover_L48\",\n    name=\"NLCD 2019\",\n    format=\"image/png\",\n    attribution=\"MRLC\",\n    transparent=True,\n)\nMap\n</pre> Map = geemap.Map(center=[40, -100], zoom=4) url = \"https://www.mrlc.gov/geoserver/mrlc_display/NLCD_2019_Land_Cover_L48/wms?\" Map.add_wms_layer(     url=url,     layers=\"NLCD_2019_Land_Cover_L48\",     name=\"NLCD 2019\",     format=\"image/png\",     attribution=\"MRLC\",     transparent=True, ) Map In\u00a0[\u00a0]: Copied! <pre>image = ee.Image(\"USGS/SRTMGL1_003\")\nimage\n</pre> image = ee.Image(\"USGS/SRTMGL1_003\") image In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map(center=[21.79, 70.87], zoom=3)\nimage = ee.Image(\"USGS/SRTMGL1_003\")\nvis_params = {\n    \"min\": 0,\n    \"max\": 6000,\n    \"palette\": [\"006633\", \"E5FFCC\", \"662A00\", \"D8D8D8\", \"F5F5F5\"],\n}\nMap.addLayer(image, vis_params, \"SRTM\")\nMap\n</pre> Map = geemap.Map(center=[21.79, 70.87], zoom=3) image = ee.Image(\"USGS/SRTMGL1_003\") vis_params = {     \"min\": 0,     \"max\": 6000,     \"palette\": [\"006633\", \"E5FFCC\", \"662A00\", \"D8D8D8\", \"F5F5F5\"], } Map.addLayer(image, vis_params, \"SRTM\") Map In\u00a0[\u00a0]: Copied! <pre>collection = ee.ImageCollection(\"COPERNICUS/S2_SR\")\n</pre> collection = ee.ImageCollection(\"COPERNICUS/S2_SR\") In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map()\ncollection = ee.ImageCollection(\"COPERNICUS/S2_SR\")\nimage = collection.median()\n\nvis = {\n    \"min\": 0.0,\n    \"max\": 3000,\n    \"bands\": [\"B4\", \"B3\", \"B2\"],\n}\n\nMap.setCenter(83.277, 17.7009, 12)\nMap.addLayer(image, vis, \"Sentinel-2\")\nMap\n</pre> Map = geemap.Map() collection = ee.ImageCollection(\"COPERNICUS/S2_SR\") image = collection.median()  vis = {     \"min\": 0.0,     \"max\": 3000,     \"bands\": [\"B4\", \"B3\", \"B2\"], }  Map.setCenter(83.277, 17.7009, 12) Map.addLayer(image, vis, \"Sentinel-2\") Map In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map()\ncollection = (\n    ee.ImageCollection(\"COPERNICUS/S2_SR\")\n    .filterDate(\"2021-01-01\", \"2022-01-01\")\n    .filter(ee.Filter.lt(\"CLOUDY_PIXEL_PERCENTAGE\", 5))\n)\nimage = collection.median()\n\nvis = {\n    \"min\": 0.0,\n    \"max\": 3000,\n    \"bands\": [\"B4\", \"B3\", \"B2\"],\n}\n\nMap.setCenter(83.277, 17.7009, 12)\nMap.addLayer(image, vis, \"Sentinel-2\")\nMap\n</pre> Map = geemap.Map() collection = (     ee.ImageCollection(\"COPERNICUS/S2_SR\")     .filterDate(\"2021-01-01\", \"2022-01-01\")     .filter(ee.Filter.lt(\"CLOUDY_PIXEL_PERCENTAGE\", 5)) ) image = collection.median()  vis = {     \"min\": 0.0,     \"max\": 3000,     \"bands\": [\"B4\", \"B3\", \"B2\"], }  Map.setCenter(83.277, 17.7009, 12) Map.addLayer(image, vis, \"Sentinel-2\") Map In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map()\nfc = ee.FeatureCollection(\"TIGER/2016/Roads\")\nMap.setCenter(-73.9596, 40.7688, 12)\nMap.addLayer(fc, {}, \"Census roads\")\nMap\n</pre> Map = geemap.Map() fc = ee.FeatureCollection(\"TIGER/2016/Roads\") Map.setCenter(-73.9596, 40.7688, 12) Map.addLayer(fc, {}, \"Census roads\") Map In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map()\nstates = ee.FeatureCollection(\"TIGER/2018/States\")\nfc = states.filter(ee.Filter.eq(\"NAME\", \"Louisiana\"))\nMap.addLayer(fc, {}, \"Louisiana\")\nMap.centerObject(fc)\nMap\n</pre> Map = geemap.Map() states = ee.FeatureCollection(\"TIGER/2018/States\") fc = states.filter(ee.Filter.eq(\"NAME\", \"Louisiana\")) Map.addLayer(fc, {}, \"Louisiana\") Map.centerObject(fc) Map In\u00a0[\u00a0]: Copied! <pre>feat = fc.first()\nfeat.toDictionary()\n</pre> feat = fc.first() feat.toDictionary() In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map()\nstates = ee.FeatureCollection(\"TIGER/2018/States\")\nfc = states.filter(ee.Filter.inList(\"NAME\", [\"California\", \"Oregon\", \"Washington\"]))\nMap.addLayer(fc, {}, \"West Coast\")\nMap.centerObject(fc)\nMap\n</pre> Map = geemap.Map() states = ee.FeatureCollection(\"TIGER/2018/States\") fc = states.filter(ee.Filter.inList(\"NAME\", [\"California\", \"Oregon\", \"Washington\"])) Map.addLayer(fc, {}, \"West Coast\") Map.centerObject(fc) Map In\u00a0[\u00a0]: Copied! <pre>region = Map.user_roi\nif region is None:\n    region = ee.Geometry.BBox(-88.40, 29.88, -77.90, 35.39)\n\nfc = ee.FeatureCollection(\"TIGER/2018/States\").filterBounds(region)\nMap.addLayer(fc, {}, \"Southeastern U.S.\")\nMap.centerObject(fc)\n</pre> region = Map.user_roi if region is None:     region = ee.Geometry.BBox(-88.40, 29.88, -77.90, 35.39)  fc = ee.FeatureCollection(\"TIGER/2018/States\").filterBounds(region) Map.addLayer(fc, {}, \"Southeastern U.S.\") Map.centerObject(fc) In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map(center=[40, -100], zoom=4)\nstates = ee.FeatureCollection(\"TIGER/2018/States\")\nMap.addLayer(states, {}, \"US States\")\nMap\n</pre> Map = geemap.Map(center=[40, -100], zoom=4) states = ee.FeatureCollection(\"TIGER/2018/States\") Map.addLayer(states, {}, \"US States\") Map In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map(center=[40, -100], zoom=4)\nstates = ee.FeatureCollection(\"TIGER/2018/States\")\nstyle = {\"color\": \"0000ffff\", \"width\": 2, \"lineType\": \"solid\", \"fillColor\": \"FF000080\"}\nMap.addLayer(states.style(**style), {}, \"US States\")\nMap\n</pre> Map = geemap.Map(center=[40, -100], zoom=4) states = ee.FeatureCollection(\"TIGER/2018/States\") style = {\"color\": \"0000ffff\", \"width\": 2, \"lineType\": \"solid\", \"fillColor\": \"FF000080\"} Map.addLayer(states.style(**style), {}, \"US States\") Map In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map(center=[40, -100], zoom=4)\nstates = ee.FeatureCollection(\"TIGER/2018/States\")\nvis_params = {\n    \"color\": \"000000\",\n    \"colorOpacity\": 1,\n    \"pointSize\": 3,\n    \"pointShape\": \"circle\",\n    \"width\": 2,\n    \"lineType\": \"solid\",\n    \"fillColorOpacity\": 0.66,\n}\npalette = [\"006633\", \"E5FFCC\", \"662A00\", \"D8D8D8\", \"F5F5F5\"]\nMap.add_styled_vector(\n    states, column=\"NAME\", palette=palette, layer_name=\"Styled vector\", **vis_params\n)\nMap\n</pre> Map = geemap.Map(center=[40, -100], zoom=4) states = ee.FeatureCollection(\"TIGER/2018/States\") vis_params = {     \"color\": \"000000\",     \"colorOpacity\": 1,     \"pointSize\": 3,     \"pointShape\": \"circle\",     \"width\": 2,     \"lineType\": \"solid\",     \"fillColorOpacity\": 0.66, } palette = [\"006633\", \"E5FFCC\", \"662A00\", \"D8D8D8\", \"F5F5F5\"] Map.add_styled_vector(     states, column=\"NAME\", palette=palette, layer_name=\"Styled vector\", **vis_params ) Map In\u00a0[\u00a0]: Copied! <pre>dataset_xyz = ee.Image(\"USGS/SRTMGL1_003\")\nMap.addLayer(dataset_xyz, {}, \"USGS/SRTMGL1_003\")\n</pre> dataset_xyz = ee.Image(\"USGS/SRTMGL1_003\") Map.addLayer(dataset_xyz, {}, \"USGS/SRTMGL1_003\") In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map()\ndem = ee.Image(\"USGS/SRTMGL1_003\")\nvis_params = {\n    \"min\": 0,\n    \"max\": 4000,\n    \"palette\": [\"006633\", \"E5FFCC\", \"662A00\", \"D8D8D8\", \"F5F5F5\"],\n}\nMap.addLayer(dem, vis_params, \"SRTM DEM\")\nMap\n</pre> Map = geemap.Map() dem = ee.Image(\"USGS/SRTMGL1_003\") vis_params = {     \"min\": 0,     \"max\": 4000,     \"palette\": [\"006633\", \"E5FFCC\", \"662A00\", \"D8D8D8\", \"F5F5F5\"], } Map.addLayer(dem, vis_params, \"SRTM DEM\") Map In\u00a0[\u00a0]: Copied! <pre>from geemap.datasets import DATA\n</pre> from geemap.datasets import DATA In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map(center=[40, -100], zoom=4)\ndataset = ee.Image(DATA.USGS_GAP_CONUS_2011)\nMap.addLayer(dataset, {}, \"GAP CONUS\")\nMap\n</pre> Map = geemap.Map(center=[40, -100], zoom=4) dataset = ee.Image(DATA.USGS_GAP_CONUS_2011) Map.addLayer(dataset, {}, \"GAP CONUS\") Map In\u00a0[\u00a0]: Copied! <pre>from geemap.datasets import get_metadata\n\nget_metadata(DATA.USGS_GAP_CONUS_2011)\n</pre> from geemap.datasets import get_metadata  get_metadata(DATA.USGS_GAP_CONUS_2011) In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map(center=(40, -100), zoom=4)\n\ndem = ee.Image(\"USGS/SRTMGL1_003\")\nlandsat7 = ee.Image(\"LANDSAT/LE7_TOA_5YEAR/1999_2003\").select(\n    [\"B1\", \"B2\", \"B3\", \"B4\", \"B5\", \"B7\"]\n)\nstates = ee.FeatureCollection(\"TIGER/2018/States\")\n\nvis_params = {\n    \"min\": 0,\n    \"max\": 4000,\n    \"palette\": [\"006633\", \"E5FFCC\", \"662A00\", \"D8D8D8\", \"F5F5F5\"],\n}\n\nMap.addLayer(dem, vis_params, \"SRTM DEM\")\nMap.addLayer(\n    landsat7,\n    {\"bands\": [\"B4\", \"B3\", \"B2\"], \"min\": 20, \"max\": 200, \"gamma\": 2.0},\n    \"Landsat 7\",\n)\nMap.addLayer(states, {}, \"US States\")\nMap\n</pre> Map = geemap.Map(center=(40, -100), zoom=4)  dem = ee.Image(\"USGS/SRTMGL1_003\") landsat7 = ee.Image(\"LANDSAT/LE7_TOA_5YEAR/1999_2003\").select(     [\"B1\", \"B2\", \"B3\", \"B4\", \"B5\", \"B7\"] ) states = ee.FeatureCollection(\"TIGER/2018/States\")  vis_params = {     \"min\": 0,     \"max\": 4000,     \"palette\": [\"006633\", \"E5FFCC\", \"662A00\", \"D8D8D8\", \"F5F5F5\"], }  Map.addLayer(dem, vis_params, \"SRTM DEM\") Map.addLayer(     landsat7,     {\"bands\": [\"B4\", \"B3\", \"B2\"], \"min\": 20, \"max\": 200, \"gamma\": 2.0},     \"Landsat 7\", ) Map.addLayer(states, {}, \"US States\") Map In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map()\nMap\n</pre> Map = geemap.Map() Map In\u00a0[\u00a0]: Copied! <pre># Load an image.\nimage = ee.Image(\"LANDSAT/LC08/C02/T1_TOA/LC08_044034_20140318\")\n\n# Define the visualization parameters.\nvizParams = {\"bands\": [\"B5\", \"B4\", \"B3\"], \"min\": 0, \"max\": 0.5, \"gamma\": [0.95, 1.1, 1]}\n\n# Center the map and display the image.\nMap.setCenter(-122.1899, 37.5010, 10)\n# San Francisco Bay\nMap.addLayer(image, vizParams, \"False color composite\")\n</pre> # Load an image. image = ee.Image(\"LANDSAT/LC08/C02/T1_TOA/LC08_044034_20140318\")  # Define the visualization parameters. vizParams = {\"bands\": [\"B5\", \"B4\", \"B3\"], \"min\": 0, \"max\": 0.5, \"gamma\": [0.95, 1.1, 1]}  # Center the map and display the image. Map.setCenter(-122.1899, 37.5010, 10) # San Francisco Bay Map.addLayer(image, vizParams, \"False color composite\") In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map(center=[40, -100], zoom=4)\n\nlandsat7 = ee.Image(\"LANDSAT/LE7_TOA_5YEAR/1999_2003\").select(\n    [\"B1\", \"B2\", \"B3\", \"B4\", \"B5\", \"B7\"]\n)\n\nlandsat_vis = {\"bands\": [\"B4\", \"B3\", \"B2\"], \"gamma\": 1.4}\nMap.addLayer(landsat7, landsat_vis, \"Landsat\")\n\nhyperion = ee.ImageCollection(\"EO1/HYPERION\").filter(\n    ee.Filter.date(\"2016-01-01\", \"2017-03-01\")\n)\n\nhyperion_vis = {\n    \"min\": 1000.0,\n    \"max\": 14000.0,\n    \"gamma\": 2.5,\n}\nMap.addLayer(hyperion, hyperion_vis, \"Hyperion\")\nMap\n</pre> Map = geemap.Map(center=[40, -100], zoom=4)  landsat7 = ee.Image(\"LANDSAT/LE7_TOA_5YEAR/1999_2003\").select(     [\"B1\", \"B2\", \"B3\", \"B4\", \"B5\", \"B7\"] )  landsat_vis = {\"bands\": [\"B4\", \"B3\", \"B2\"], \"gamma\": 1.4} Map.addLayer(landsat7, landsat_vis, \"Landsat\")  hyperion = ee.ImageCollection(\"EO1/HYPERION\").filter(     ee.Filter.date(\"2016-01-01\", \"2017-03-01\") )  hyperion_vis = {     \"min\": 1000.0,     \"max\": 14000.0,     \"gamma\": 2.5, } Map.addLayer(hyperion, hyperion_vis, \"Hyperion\") Map In\u00a0[\u00a0]: Copied! <pre>Map.set_plot_options(add_marker_cluster=True, overlay=True)\n</pre> Map.set_plot_options(add_marker_cluster=True, overlay=True) In\u00a0[\u00a0]: Copied! <pre>legends = geemap.builtin_legends\nfor legend in legends:\n    print(legend)\n</pre> legends = geemap.builtin_legends for legend in legends:     print(legend) In\u00a0[\u00a0]: Copied! <pre>Map.add_legend(builtin_legend=\"NLCD\")\n</pre> Map.add_legend(builtin_legend=\"NLCD\") In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map(center=[40, -100], zoom=4)\nMap.add_basemap(\"HYBRID\")\n\nnlcd = ee.Image(\"USGS/NLCD_RELEASES/2019_REL/NLCD/2019\")\nlandcover = nlcd.select(\"landcover\")\n\nMap.addLayer(landcover, {}, \"NLCD Land Cover 2019\")\nMap.add_legend(title=\"NLCD Land Cover Classification\", builtin_legend=\"NLCD\")\nMap\n</pre> Map = geemap.Map(center=[40, -100], zoom=4) Map.add_basemap(\"HYBRID\")  nlcd = ee.Image(\"USGS/NLCD_RELEASES/2019_REL/NLCD/2019\") landcover = nlcd.select(\"landcover\")  Map.addLayer(landcover, {}, \"NLCD Land Cover 2019\") Map.add_legend(title=\"NLCD Land Cover Classification\", builtin_legend=\"NLCD\") Map In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map(add_google_map=False)\n\nlabels = [\"One\", \"Two\", \"Three\", \"Four\", \"ect\"]\n\n# colors can be defined using either hex code or RGB (0-255, 0-255, 0-255)\ncolors = [\"#8DD3C7\", \"#FFFFB3\", \"#BEBADA\", \"#FB8072\", \"#80B1D3\"]\n# legend_colors = [(255, 0, 0), (127, 255, 0), (127, 18, 25), (36, 70, 180), (96, 68 123)]\n\nMap.add_legend(labels=labels, colors=colors, position=\"bottomright\")\nMap\n</pre> Map = geemap.Map(add_google_map=False)  labels = [\"One\", \"Two\", \"Three\", \"Four\", \"ect\"]  # colors can be defined using either hex code or RGB (0-255, 0-255, 0-255) colors = [\"#8DD3C7\", \"#FFFFB3\", \"#BEBADA\", \"#FB8072\", \"#80B1D3\"] # legend_colors = [(255, 0, 0), (127, 255, 0), (127, 18, 25), (36, 70, 180), (96, 68 123)]  Map.add_legend(labels=labels, colors=colors, position=\"bottomright\") Map In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map(center=[40, -100], zoom=4)\n\nlegend_dict = {\n    \"11 Open Water\": \"466b9f\",\n    \"12 Perennial Ice/Snow\": \"d1def8\",\n    \"21 Developed, Open Space\": \"dec5c5\",\n    \"22 Developed, Low Intensity\": \"d99282\",\n    \"23 Developed, Medium Intensity\": \"eb0000\",\n    \"24 Developed High Intensity\": \"ab0000\",\n    \"31 Barren Land (Rock/Sand/Clay)\": \"b3ac9f\",\n    \"41 Deciduous Forest\": \"68ab5f\",\n    \"42 Evergreen Forest\": \"1c5f2c\",\n    \"43 Mixed Forest\": \"b5c58f\",\n    \"51 Dwarf Scrub\": \"af963c\",\n    \"52 Shrub/Scrub\": \"ccb879\",\n    \"71 Grassland/Herbaceous\": \"dfdfc2\",\n    \"72 Sedge/Herbaceous\": \"d1d182\",\n    \"73 Lichens\": \"a3cc51\",\n    \"74 Moss\": \"82ba9e\",\n    \"81 Pasture/Hay\": \"dcd939\",\n    \"82 Cultivated Crops\": \"ab6c28\",\n    \"90 Woody Wetlands\": \"b8d9eb\",\n    \"95 Emergent Herbaceous Wetlands\": \"6c9fb8\",\n}\n\nnlcd = ee.Image(\"USGS/NLCD_RELEASES/2019_REL/NLCD/2019\")\nlandcover = nlcd.select(\"landcover\")\n\nMap.addLayer(landcover, {}, \"NLCD Land Cover 2019\")\nMap.add_legend(title=\"NLCD Land Cover Classification\", legend_dict=legend_dict)\nMap\n</pre> Map = geemap.Map(center=[40, -100], zoom=4)  legend_dict = {     \"11 Open Water\": \"466b9f\",     \"12 Perennial Ice/Snow\": \"d1def8\",     \"21 Developed, Open Space\": \"dec5c5\",     \"22 Developed, Low Intensity\": \"d99282\",     \"23 Developed, Medium Intensity\": \"eb0000\",     \"24 Developed High Intensity\": \"ab0000\",     \"31 Barren Land (Rock/Sand/Clay)\": \"b3ac9f\",     \"41 Deciduous Forest\": \"68ab5f\",     \"42 Evergreen Forest\": \"1c5f2c\",     \"43 Mixed Forest\": \"b5c58f\",     \"51 Dwarf Scrub\": \"af963c\",     \"52 Shrub/Scrub\": \"ccb879\",     \"71 Grassland/Herbaceous\": \"dfdfc2\",     \"72 Sedge/Herbaceous\": \"d1d182\",     \"73 Lichens\": \"a3cc51\",     \"74 Moss\": \"82ba9e\",     \"81 Pasture/Hay\": \"dcd939\",     \"82 Cultivated Crops\": \"ab6c28\",     \"90 Woody Wetlands\": \"b8d9eb\",     \"95 Emergent Herbaceous Wetlands\": \"6c9fb8\", }  nlcd = ee.Image(\"USGS/NLCD_RELEASES/2019_REL/NLCD/2019\") landcover = nlcd.select(\"landcover\")  Map.addLayer(landcover, {}, \"NLCD Land Cover 2019\") Map.add_legend(title=\"NLCD Land Cover Classification\", legend_dict=legend_dict) Map In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map()\n\ndem = ee.Image(\"USGS/SRTMGL1_003\")\nvis_params = {\n    \"min\": 0,\n    \"max\": 4000,\n    \"palette\": [\"006633\", \"E5FFCC\", \"662A00\", \"D8D8D8\", \"F5F5F5\"],\n}\n\nMap.addLayer(dem, vis_params, \"SRTM DEM\")\n</pre> Map = geemap.Map()  dem = ee.Image(\"USGS/SRTMGL1_003\") vis_params = {     \"min\": 0,     \"max\": 4000,     \"palette\": [\"006633\", \"E5FFCC\", \"662A00\", \"D8D8D8\", \"F5F5F5\"], }  Map.addLayer(dem, vis_params, \"SRTM DEM\") In\u00a0[\u00a0]: Copied! <pre>Map.add_colorbar(vis_params, label=\"Elevation (m)\", layer_name=\"SRTM DEM\")\n</pre> Map.add_colorbar(vis_params, label=\"Elevation (m)\", layer_name=\"SRTM DEM\") In\u00a0[\u00a0]: Copied! <pre>Map.add_colorbar(\n    vis_params, label=\"Elevation (m)\", layer_name=\"SRTM DEM\", orientation=\"vertical\"\n)\n</pre> Map.add_colorbar(     vis_params, label=\"Elevation (m)\", layer_name=\"SRTM DEM\", orientation=\"vertical\" ) In\u00a0[\u00a0]: Copied! <pre>Map.add_colorbar(\n    vis_params,\n    label=\"Elevation (m)\",\n    layer_name=\"SRTM DEM\",\n    orientation=\"vertical\",\n    transparent_bg=True,\n)\nMap\n</pre> Map.add_colorbar(     vis_params,     label=\"Elevation (m)\",     layer_name=\"SRTM DEM\",     orientation=\"vertical\",     transparent_bg=True, ) Map In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map()\nMap.split_map(left_layer=\"HYBRID\", right_layer=\"TERRAIN\")\nMap\n</pre> Map = geemap.Map() Map.split_map(left_layer=\"HYBRID\", right_layer=\"TERRAIN\") Map In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map(center=(40, -100), zoom=4, height=600)\n\nnlcd_2001 = ee.Image(\"USGS/NLCD_RELEASES/2019_REL/NLCD/2001\").select(\"landcover\")\nnlcd_2019 = ee.Image(\"USGS/NLCD_RELEASES/2019_REL/NLCD/2019\").select(\"landcover\")\n\nleft_layer = geemap.ee_tile_layer(nlcd_2001, {}, \"NLCD 2001\")\nright_layer = geemap.ee_tile_layer(nlcd_2019, {}, \"NLCD 2019\")\n\nMap.split_map(left_layer, right_layer)\nMap\n</pre> Map = geemap.Map(center=(40, -100), zoom=4, height=600)  nlcd_2001 = ee.Image(\"USGS/NLCD_RELEASES/2019_REL/NLCD/2001\").select(\"landcover\") nlcd_2019 = ee.Image(\"USGS/NLCD_RELEASES/2019_REL/NLCD/2019\").select(\"landcover\")  left_layer = geemap.ee_tile_layer(nlcd_2001, {}, \"NLCD 2001\") right_layer = geemap.ee_tile_layer(nlcd_2019, {}, \"NLCD 2019\")  Map.split_map(left_layer, right_layer) Map In\u00a0[\u00a0]: Copied! <pre>image = (\n    ee.ImageCollection(\"COPERNICUS/S2\")\n    .filterDate(\"2018-09-01\", \"2018-09-30\")\n    .map(lambda img: img.divide(10000))\n    .median()\n)\n\nvis_params = [\n    {\"bands\": [\"B4\", \"B3\", \"B2\"], \"min\": 0, \"max\": 0.3, \"gamma\": 1.3},\n    {\"bands\": [\"B8\", \"B11\", \"B4\"], \"min\": 0, \"max\": 0.3, \"gamma\": 1.3},\n    {\"bands\": [\"B8\", \"B4\", \"B3\"], \"min\": 0, \"max\": 0.3, \"gamma\": 1.3},\n    {\"bands\": [\"B12\", \"B12\", \"B4\"], \"min\": 0, \"max\": 0.3, \"gamma\": 1.3},\n]\n\nlabels = [\n    \"Natural Color (B4/B3/B2)\",\n    \"Land/Water (B8/B11/B4)\",\n    \"Color Infrared (B8/B4/B3)\",\n    \"Vegetation (B12/B11/B4)\",\n]\n\ngeemap.linked_maps(\n    rows=2,\n    cols=2,\n    height=\"300px\",\n    center=[38.4151, 21.2712],\n    zoom=12,\n    ee_objects=[image],\n    vis_params=vis_params,\n    labels=labels,\n    label_position=\"topright\",\n)\n</pre> image = (     ee.ImageCollection(\"COPERNICUS/S2\")     .filterDate(\"2018-09-01\", \"2018-09-30\")     .map(lambda img: img.divide(10000))     .median() )  vis_params = [     {\"bands\": [\"B4\", \"B3\", \"B2\"], \"min\": 0, \"max\": 0.3, \"gamma\": 1.3},     {\"bands\": [\"B8\", \"B11\", \"B4\"], \"min\": 0, \"max\": 0.3, \"gamma\": 1.3},     {\"bands\": [\"B8\", \"B4\", \"B3\"], \"min\": 0, \"max\": 0.3, \"gamma\": 1.3},     {\"bands\": [\"B12\", \"B12\", \"B4\"], \"min\": 0, \"max\": 0.3, \"gamma\": 1.3}, ]  labels = [     \"Natural Color (B4/B3/B2)\",     \"Land/Water (B8/B11/B4)\",     \"Color Infrared (B8/B4/B3)\",     \"Vegetation (B12/B11/B4)\", ]  geemap.linked_maps(     rows=2,     cols=2,     height=\"300px\",     center=[38.4151, 21.2712],     zoom=12,     ee_objects=[image],     vis_params=vis_params,     labels=labels,     label_position=\"topright\", ) In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map(center=[40, -100], zoom=4)\ncollection = ee.ImageCollection(\"USGS/NLCD_RELEASES/2019_REL/NLCD\").select(\"landcover\")\nvis_params = {\"bands\": [\"landcover\"]}\nyears = collection.aggregate_array(\"system:index\").getInfo()\nyears\n</pre> Map = geemap.Map(center=[40, -100], zoom=4) collection = ee.ImageCollection(\"USGS/NLCD_RELEASES/2019_REL/NLCD\").select(\"landcover\") vis_params = {\"bands\": [\"landcover\"]} years = collection.aggregate_array(\"system:index\").getInfo() years In\u00a0[\u00a0]: Copied! <pre>Map.ts_inspector(\n    left_ts=collection,\n    right_ts=collection,\n    left_names=years,\n    right_names=years,\n    left_vis=vis_params,\n    right_vis=vis_params,\n    width=\"80px\",\n)\nMap\n</pre> Map.ts_inspector(     left_ts=collection,     right_ts=collection,     left_names=years,     right_names=years,     left_vis=vis_params,     right_vis=vis_params,     width=\"80px\", ) Map In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map()\n\ncollection = (\n    ee.ImageCollection(\"MODIS/MCD43A4_006_NDVI\")\n    .filter(ee.Filter.date(\"2018-06-01\", \"2018-07-01\"))\n    .select(\"NDVI\")\n)\nvis_params = {\n    \"min\": 0.0,\n    \"max\": 1.0,\n    \"palette\": \"ndvi\",\n}\n\nMap.add_time_slider(collection, vis_params, time_interval=2)\nMap\n</pre> Map = geemap.Map()  collection = (     ee.ImageCollection(\"MODIS/MCD43A4_006_NDVI\")     .filter(ee.Filter.date(\"2018-06-01\", \"2018-07-01\"))     .select(\"NDVI\") ) vis_params = {     \"min\": 0.0,     \"max\": 1.0,     \"palette\": \"ndvi\", }  Map.add_time_slider(collection, vis_params, time_interval=2) Map In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map()\n\ncollection = (\n    ee.ImageCollection(\"NOAA/GFS0P25\")\n    .filterDate(\"2018-12-22\", \"2018-12-23\")\n    .limit(24)\n    .select(\"temperature_2m_above_ground\")\n)\n\nvis_params = {\n    \"min\": -40.0,\n    \"max\": 35.0,\n    \"palette\": [\"blue\", \"purple\", \"cyan\", \"green\", \"yellow\", \"red\"],\n}\n\nlabels = [str(n).zfill(2) + \":00\" for n in range(0, 24)]\nMap.add_time_slider(collection, vis_params, labels=labels, time_interval=1, opacity=0.8)\nMap\n</pre> Map = geemap.Map()  collection = (     ee.ImageCollection(\"NOAA/GFS0P25\")     .filterDate(\"2018-12-22\", \"2018-12-23\")     .limit(24)     .select(\"temperature_2m_above_ground\") )  vis_params = {     \"min\": -40.0,     \"max\": 35.0,     \"palette\": [\"blue\", \"purple\", \"cyan\", \"green\", \"yellow\", \"red\"], }  labels = [str(n).zfill(2) + \":00\" for n in range(0, 24)] Map.add_time_slider(collection, vis_params, labels=labels, time_interval=1, opacity=0.8) Map In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map(center=[37.75, -122.45], zoom=12)\n\ncollection = (\n    ee.ImageCollection(\"COPERNICUS/S2_SR\")\n    .filterBounds(ee.Geometry.Point([-122.45, 37.75]))\n    .filterMetadata(\"CLOUDY_PIXEL_PERCENTAGE\", \"less_than\", 10)\n)\n\nvis_params = {\"min\": 0, \"max\": 4000, \"bands\": [\"B8\", \"B4\", \"B3\"]}\n\nMap.add_time_slider(collection, vis_params)\nMap\n</pre> Map = geemap.Map(center=[37.75, -122.45], zoom=12)  collection = (     ee.ImageCollection(\"COPERNICUS/S2_SR\")     .filterBounds(ee.Geometry.Point([-122.45, 37.75]))     .filterMetadata(\"CLOUDY_PIXEL_PERCENTAGE\", \"less_than\", 10) )  vis_params = {\"min\": 0, \"max\": 4000, \"bands\": [\"B8\", \"B4\", \"B3\"]}  Map.add_time_slider(collection, vis_params) Map In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map(center=[40, -100], zoom=4)\n\n# Add NASA SRTM\ndem = ee.Image(\"USGS/SRTMGL1_003\")\ndem_vis = {\n    \"min\": 0,\n    \"max\": 4000,\n    \"palette\": [\"006633\", \"E5FFCC\", \"662A00\", \"D8D8D8\", \"F5F5F5\"],\n}\nMap.addLayer(dem, dem_vis, \"SRTM DEM\")\n\n# Add 5-year Landsat TOA composite\nlandsat = ee.Image(\"LANDSAT/LE7_TOA_5YEAR/1999_2003\")\nlandsat_vis = {\"bands\": [\"B4\", \"B3\", \"B2\"], \"gamma\": 1.4}\nMap.addLayer(landsat, landsat_vis, \"Landsat\", False)\n\n# Add US Census States\nstates = ee.FeatureCollection(\"TIGER/2018/States\")\nstyle = {\"fillColor\": \"00000000\"}\nMap.addLayer(states.style(**style), {}, \"US States\")\nMap\n</pre> Map = geemap.Map(center=[40, -100], zoom=4)  # Add NASA SRTM dem = ee.Image(\"USGS/SRTMGL1_003\") dem_vis = {     \"min\": 0,     \"max\": 4000,     \"palette\": [\"006633\", \"E5FFCC\", \"662A00\", \"D8D8D8\", \"F5F5F5\"], } Map.addLayer(dem, dem_vis, \"SRTM DEM\")  # Add 5-year Landsat TOA composite landsat = ee.Image(\"LANDSAT/LE7_TOA_5YEAR/1999_2003\") landsat_vis = {\"bands\": [\"B4\", \"B3\", \"B2\"], \"gamma\": 1.4} Map.addLayer(landsat, landsat_vis, \"Landsat\", False)  # Add US Census States states = ee.FeatureCollection(\"TIGER/2018/States\") style = {\"fillColor\": \"00000000\"} Map.addLayer(states.style(**style), {}, \"US States\") Map In\u00a0[\u00a0]: Copied! <pre>out_dem_stats = \"dem_stats.csv\"\ngeemap.zonal_stats(\n    dem, states, out_dem_stats, stat_type=\"MEAN\", scale=1000, return_fc=False\n)\n</pre> out_dem_stats = \"dem_stats.csv\" geemap.zonal_stats(     dem, states, out_dem_stats, stat_type=\"MEAN\", scale=1000, return_fc=False ) In\u00a0[\u00a0]: Copied! <pre>out_landsat_stats = \"landsat_stats.csv\"\ngeemap.zonal_stats(\n    landsat,\n    states,\n    out_landsat_stats,\n    stat_type=\"MEAN\",\n    scale=1000,\n    return_fc=False,\n)\n</pre> out_landsat_stats = \"landsat_stats.csv\" geemap.zonal_stats(     landsat,     states,     out_landsat_stats,     stat_type=\"MEAN\",     scale=1000,     return_fc=False, ) In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map(center=[40, -100], zoom=4)\n\n# Add NLCD data\ndataset = ee.Image(\"USGS/NLCD_RELEASES/2019_REL/NLCD/2019\")\nlandcover = dataset.select(\"landcover\")\nMap.addLayer(landcover, {}, \"NLCD 2019\")\n\n# Add US census states\nstates = ee.FeatureCollection(\"TIGER/2018/States\")\nstyle = {\"fillColor\": \"00000000\"}\nMap.addLayer(states.style(**style), {}, \"US States\")\n\n# Add NLCD legend\nMap.add_legend(title=\"NLCD Land Cover\", builtin_legend=\"NLCD\")\nMap\n</pre> Map = geemap.Map(center=[40, -100], zoom=4)  # Add NLCD data dataset = ee.Image(\"USGS/NLCD_RELEASES/2019_REL/NLCD/2019\") landcover = dataset.select(\"landcover\") Map.addLayer(landcover, {}, \"NLCD 2019\")  # Add US census states states = ee.FeatureCollection(\"TIGER/2018/States\") style = {\"fillColor\": \"00000000\"} Map.addLayer(states.style(**style), {}, \"US States\")  # Add NLCD legend Map.add_legend(title=\"NLCD Land Cover\", builtin_legend=\"NLCD\") Map In\u00a0[\u00a0]: Copied! <pre>nlcd_stats = \"nlcd_stats.csv\"\n\ngeemap.zonal_stats_by_group(\n    landcover,\n    states,\n    nlcd_stats,\n    stat_type=\"SUM\",\n    denominator=1e6,\n    decimal_places=2,\n)\n</pre> nlcd_stats = \"nlcd_stats.csv\"  geemap.zonal_stats_by_group(     landcover,     states,     nlcd_stats,     stat_type=\"SUM\",     denominator=1e6,     decimal_places=2, ) In\u00a0[\u00a0]: Copied! <pre>nlcd_stats = \"nlcd_stats_pct.csv\"\n\ngeemap.zonal_stats_by_group(\n    landcover,\n    states,\n    nlcd_stats,\n    stat_type=\"PERCENTAGE\",\n    denominator=1e6,\n    decimal_places=2,\n)\n</pre> nlcd_stats = \"nlcd_stats_pct.csv\"  geemap.zonal_stats_by_group(     landcover,     states,     nlcd_stats,     stat_type=\"PERCENTAGE\",     denominator=1e6,     decimal_places=2, ) In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map(center=[40, -100], zoom=4)\ndem = ee.Image(\"USGS/3DEP/10m\")\nvis = {\"min\": 0, \"max\": 4000, \"palette\": \"terrain\"}\nMap.addLayer(dem, vis, \"DEM\")\nMap\n</pre> Map = geemap.Map(center=[40, -100], zoom=4) dem = ee.Image(\"USGS/3DEP/10m\") vis = {\"min\": 0, \"max\": 4000, \"palette\": \"terrain\"} Map.addLayer(dem, vis, \"DEM\") Map In\u00a0[\u00a0]: Copied! <pre>landcover = ee.Image(\"USGS/NLCD_RELEASES/2019_REL/NLCD/2019\").select(\"landcover\")\nMap.addLayer(landcover, {}, \"NLCD 2019\")\nMap.add_legend(title=\"NLCD Land Cover Classification\", builtin_legend=\"NLCD\")\n</pre> landcover = ee.Image(\"USGS/NLCD_RELEASES/2019_REL/NLCD/2019\").select(\"landcover\") Map.addLayer(landcover, {}, \"NLCD 2019\") Map.add_legend(title=\"NLCD Land Cover Classification\", builtin_legend=\"NLCD\") In\u00a0[\u00a0]: Copied! <pre>stats = geemap.image_stats_by_zone(dem, landcover, reducer=\"MEAN\")\nstats\n</pre> stats = geemap.image_stats_by_zone(dem, landcover, reducer=\"MEAN\") stats In\u00a0[\u00a0]: Copied! <pre>stats.to_csv(\"mean.csv\", index=False)\n</pre> stats.to_csv(\"mean.csv\", index=False) In\u00a0[\u00a0]: Copied! <pre>geemap.image_stats_by_zone(dem, landcover, out_csv=\"std.csv\", reducer=\"STD\")\n</pre> geemap.image_stats_by_zone(dem, landcover, out_csv=\"std.csv\", reducer=\"STD\") In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map()\n\nimage = ee.Image(\"LANDSAT/LC08/C02/T1_TOA/LC08_044034_20140318\").select(\n    [\"B5\", \"B4\", \"B3\"]\n)\n\nvis_params = {\"min\": 0, \"max\": 0.5, \"gamma\": [0.95, 1.1, 1]}\n\nMap.centerObject(image)\nMap.addLayer(image, vis_params, \"Landsat\")\nMap\n</pre> Map = geemap.Map()  image = ee.Image(\"LANDSAT/LC08/C02/T1_TOA/LC08_044034_20140318\").select(     [\"B5\", \"B4\", \"B3\"] )  vis_params = {\"min\": 0, \"max\": 0.5, \"gamma\": [0.95, 1.1, 1]}  Map.centerObject(image) Map.addLayer(image, vis_params, \"Landsat\") Map In\u00a0[\u00a0]: Copied! <pre>region = ee.Geometry.BBox(-122.5955, 37.5339, -122.0982, 37.8252)\nfc = ee.FeatureCollection(region)\nstyle = {\"color\": \"ffff00ff\", \"fillColor\": \"00000000\"}\nMap.addLayer(fc.style(**style), {}, \"ROI\")\nMap\n</pre> region = ee.Geometry.BBox(-122.5955, 37.5339, -122.0982, 37.8252) fc = ee.FeatureCollection(region) style = {\"color\": \"ffff00ff\", \"fillColor\": \"00000000\"} Map.addLayer(fc.style(**style), {}, \"ROI\") Map In\u00a0[\u00a0]: Copied! <pre>geemap.ee_export_image(image, filename=\"landsat.tif\", scale=30, region=region)\n</pre> geemap.ee_export_image(image, filename=\"landsat.tif\", scale=30, region=region) In\u00a0[\u00a0]: Copied! <pre>geemap.ee_export_image_to_drive(\n    image, description=\"landsat\", folder=\"export\", region=region, scale=30\n)\n</pre> geemap.ee_export_image_to_drive(     image, description=\"landsat\", folder=\"export\", region=region, scale=30 ) In\u00a0[\u00a0]: Copied! <pre>assetId = \"landsat_sfo\"\ngeemap.ee_export_image_to_asset(\n    image, description=\"landsat\", assetId=assetId, region=region, scale=30\n)\n</pre> assetId = \"landsat_sfo\" geemap.ee_export_image_to_asset(     image, description=\"landsat\", assetId=assetId, region=region, scale=30 ) In\u00a0[\u00a0]: Copied! <pre>point = ee.Geometry.Point(-99.2222, 46.7816)\ncollection = (\n    ee.ImageCollection(\"USDA/NAIP/DOQQ\")\n    .filterBounds(point)\n    .filterDate(\"2008-01-01\", \"2018-01-01\")\n    .filter(ee.Filter.listContains(\"system:band_names\", \"N\"))\n)\n</pre> point = ee.Geometry.Point(-99.2222, 46.7816) collection = (     ee.ImageCollection(\"USDA/NAIP/DOQQ\")     .filterBounds(point)     .filterDate(\"2008-01-01\", \"2018-01-01\")     .filter(ee.Filter.listContains(\"system:band_names\", \"N\")) ) In\u00a0[\u00a0]: Copied! <pre>collection.aggregate_array(\"system:index\")\n</pre> collection.aggregate_array(\"system:index\") In\u00a0[\u00a0]: Copied! <pre>geemap.ee_export_image_collection(collection, out_dir=\".\", scale=10)\n</pre> geemap.ee_export_image_collection(collection, out_dir=\".\", scale=10) In\u00a0[\u00a0]: Copied! <pre>geemap.ee_export_image_collection_to_drive(collection, folder=\"export\", scale=10)\n</pre> geemap.ee_export_image_collection_to_drive(collection, folder=\"export\", scale=10) In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map()\nstates = ee.FeatureCollection(\"TIGER/2018/States\")\nfc = states.filter(ee.Filter.eq(\"NAME\", \"Louisiana\"))\nMap.addLayer(fc, {}, \"Louisiana\")\nMap.centerObject(fc)\nMap\n</pre> Map = geemap.Map() states = ee.FeatureCollection(\"TIGER/2018/States\") fc = states.filter(ee.Filter.eq(\"NAME\", \"Louisiana\")) Map.addLayer(fc, {}, \"Louisiana\") Map.centerObject(fc) Map In\u00a0[\u00a0]: Copied! <pre>geemap.ee_to_shp(fc, filename=\"louisiana.shp\", selectors=None)\n</pre> geemap.ee_to_shp(fc, filename=\"louisiana.shp\", selectors=None) In\u00a0[\u00a0]: Copied! <pre>geemap.ee_to_geojson(fc, filename=\"louisiana.geojson\")\n</pre> geemap.ee_to_geojson(fc, filename=\"louisiana.geojson\") In\u00a0[\u00a0]: Copied! <pre>geemap.ee_to_csv(fc, filename=\"louisiana.csv\")\n</pre> geemap.ee_to_csv(fc, filename=\"louisiana.csv\") In\u00a0[\u00a0]: Copied! <pre>df = geemap.ee_to_df(fc)\ndf\n</pre> df = geemap.ee_to_df(fc) df In\u00a0[\u00a0]: Copied! <pre>geemap.ee_export_vector_to_drive(\n    fc, description=\"louisiana\", fileFormat=\"SHP\", folder=\"export\"\n)\n</pre> geemap.ee_export_vector_to_drive(     fc, description=\"louisiana\", fileFormat=\"SHP\", folder=\"export\" ) In\u00a0[\u00a0]: Copied! <pre>collection = ee.ImageCollection(\"COPERNICUS/S2_HARMONIZED\").filterMetadata(\n    \"CLOUDY_PIXEL_PERCENTAGE\", \"less_than\", 10\n)\n</pre> collection = ee.ImageCollection(\"COPERNICUS/S2_HARMONIZED\").filterMetadata(     \"CLOUDY_PIXEL_PERCENTAGE\", \"less_than\", 10 ) In\u00a0[\u00a0]: Copied! <pre>start_date = \"2016-01-01\"\nend_date = \"2022-12-31\"\nregion = ee.Geometry.BBox(-122.5549, 37.6968, -122.3446, 37.8111)\n</pre> start_date = \"2016-01-01\" end_date = \"2022-12-31\" region = ee.Geometry.BBox(-122.5549, 37.6968, -122.3446, 37.8111) In\u00a0[\u00a0]: Copied! <pre>images = geemap.create_timeseries(\n    collection, start_date, end_date, region, frequency=\"year\", reducer=\"median\"\n)\nimages\n</pre> images = geemap.create_timeseries(     collection, start_date, end_date, region, frequency=\"year\", reducer=\"median\" ) images In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map()\n\nvis_params = {\"min\": 0, \"max\": 4000, \"bands\": [\"B8\", \"B4\", \"B3\"]}\nlabels = [str(y) for y in range(2016, 2023)]\n\nMap.addLayer(images, vis_params, \"Sentinel-2\", False)\nMap.add_time_slider(images, vis_params, time_interval=2, labels=labels)\nMap.centerObject(region)\nMap\n</pre> Map = geemap.Map()  vis_params = {\"min\": 0, \"max\": 4000, \"bands\": [\"B8\", \"B4\", \"B3\"]} labels = [str(y) for y in range(2016, 2023)]  Map.addLayer(images, vis_params, \"Sentinel-2\", False) Map.add_time_slider(images, vis_params, time_interval=2, labels=labels) Map.centerObject(region) Map In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map()\nMap\n</pre> Map = geemap.Map() Map In\u00a0[\u00a0]: Copied! <pre>roi = Map.user_roi\nif roi is None:\n    roi = ee.Geometry.BBox(-74.7222, -8.5867, -74.1596, -8.2824)\n    Map.addLayer(roi)\n    Map.centerObject(roi)\n</pre> roi = Map.user_roi if roi is None:     roi = ee.Geometry.BBox(-74.7222, -8.5867, -74.1596, -8.2824)     Map.addLayer(roi)     Map.centerObject(roi) In\u00a0[\u00a0]: Copied! <pre>timelapse = geemap.landsat_timelapse(\n    roi,\n    out_gif=\"landsat.gif\",\n    start_year=1984,\n    end_year=2022,\n    start_date=\"01-01\",\n    end_date=\"12-31\",\n    bands=[\"SWIR1\", \"NIR\", \"Red\"],\n    frames_per_second=5,\n    title=\"Landsat Timelapse\",\n    progress_bar_color=\"blue\",\n    mp4=True,\n)\ngeemap.show_image(timelapse)\n</pre> timelapse = geemap.landsat_timelapse(     roi,     out_gif=\"landsat.gif\",     start_year=1984,     end_year=2022,     start_date=\"01-01\",     end_date=\"12-31\",     bands=[\"SWIR1\", \"NIR\", \"Red\"],     frames_per_second=5,     title=\"Landsat Timelapse\",     progress_bar_color=\"blue\",     mp4=True, ) geemap.show_image(timelapse) In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map()\nroi = ee.Geometry.BBox(-115.5541, 35.8044, -113.9035, 36.5581)\nMap.addLayer(roi)\nMap.centerObject(roi)\nMap\n</pre> Map = geemap.Map() roi = ee.Geometry.BBox(-115.5541, 35.8044, -113.9035, 36.5581) Map.addLayer(roi) Map.centerObject(roi) Map In\u00a0[\u00a0]: Copied! <pre>timelapse = geemap.landsat_timelapse(\n    roi,\n    out_gif=\"las_vegas.gif\",\n    start_year=1984,\n    end_year=2022,\n    bands=[\"NIR\", \"Red\", \"Green\"],\n    frames_per_second=5,\n    title=\"Las Vegas, NV\",\n    font_color=\"blue\",\n)\ngeemap.show_image(timelapse)\n</pre> timelapse = geemap.landsat_timelapse(     roi,     out_gif=\"las_vegas.gif\",     start_year=1984,     end_year=2022,     bands=[\"NIR\", \"Red\", \"Green\"],     frames_per_second=5,     title=\"Las Vegas, NV\",     font_color=\"blue\", ) geemap.show_image(timelapse) In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map()\nroi = ee.Geometry.BBox(113.8252, 22.1988, 114.0851, 22.3497)\nMap.addLayer(roi)\nMap.centerObject(roi)\nMap\n</pre> Map = geemap.Map() roi = ee.Geometry.BBox(113.8252, 22.1988, 114.0851, 22.3497) Map.addLayer(roi) Map.centerObject(roi) Map In\u00a0[\u00a0]: Copied! <pre>timelapse = geemap.landsat_timelapse(\n    roi,\n    out_gif=\"hong_kong.gif\",\n    start_year=1990,\n    end_year=2022,\n    start_date=\"01-01\",\n    end_date=\"12-31\",\n    bands=[\"SWIR1\", \"NIR\", \"Red\"],\n    frames_per_second=3,\n    title=\"Hong Kong\",\n)\ngeemap.show_image(timelapse)\n</pre> timelapse = geemap.landsat_timelapse(     roi,     out_gif=\"hong_kong.gif\",     start_year=1990,     end_year=2022,     start_date=\"01-01\",     end_date=\"12-31\",     bands=[\"SWIR1\", \"NIR\", \"Red\"],     frames_per_second=3,     title=\"Hong Kong\", ) geemap.show_image(timelapse) In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map()\nMap\n</pre> Map = geemap.Map() Map In\u00a0[\u00a0]: Copied! <pre>roi = Map.user_roi\nif roi is None:\n    roi = ee.Geometry.BBox(-18.6983, -36.1630, 52.2293, 38.1446)\n    Map.addLayer(roi)\n    Map.centerObject(roi)\n</pre> roi = Map.user_roi if roi is None:     roi = ee.Geometry.BBox(-18.6983, -36.1630, 52.2293, 38.1446)     Map.addLayer(roi)     Map.centerObject(roi) In\u00a0[\u00a0]: Copied! <pre>timelapse = geemap.modis_ndvi_timelapse(\n    roi,\n    out_gif=\"ndvi.gif\",\n    data=\"Terra\",\n    band=\"NDVI\",\n    start_date=\"2000-01-01\",\n    end_date=\"2022-12-31\",\n    frames_per_second=3,\n    title=\"MODIS NDVI Timelapse\",\n    overlay_data=\"countries\",\n)\ngeemap.show_image(timelapse)\n</pre> timelapse = geemap.modis_ndvi_timelapse(     roi,     out_gif=\"ndvi.gif\",     data=\"Terra\",     band=\"NDVI\",     start_date=\"2000-01-01\",     end_date=\"2022-12-31\",     frames_per_second=3,     title=\"MODIS NDVI Timelapse\",     overlay_data=\"countries\", ) geemap.show_image(timelapse) In\u00a0[77]: Copied! <pre>dataset = ee.Image(\"JRC/GSW1_4/GlobalSurfaceWater\")\ndataset.bandNames()\n</pre> dataset = ee.Image(\"JRC/GSW1_4/GlobalSurfaceWater\") dataset.bandNames() Out[77]: <ul><li>List (7 elements)<ul><li>0:occurrence</li><li>1:change_abs</li><li>2:change_norm</li><li>3:seasonality</li><li>4:recurrence</li><li>5:transition</li><li>6:max_extent</li></ul></li></ul> In\u00a0[78]: Copied! <pre>Map = geemap.Map()\nMap.add_basemap(\"HYBRID\")\nMap\n</pre> Map = geemap.Map() Map.add_basemap(\"HYBRID\") Map Out[78]: In\u00a0[79]: Copied! <pre>image = dataset.select([\"occurrence\"])\nregion = Map.user_roi  # Draw a polygon on the map\nif region is None:\n    region = ee.Geometry.BBox(-99.957, 46.8947, -99.278, 47.1531)\nvis_params = {\"min\": 0.0, \"max\": 100.0, \"palette\": [\"ffffff\", \"ffbbbb\", \"0000ff\"]}\nMap.addLayer(image, vis_params, \"Occurrence\")\nMap.addLayer(region, {}, \"ROI\", True, 0.5)\nMap.centerObject(region)\nMap.add_colorbar(vis_params, label=\"Water occurrence (%)\", layer_name=\"Occurrence\")\n</pre> image = dataset.select([\"occurrence\"]) region = Map.user_roi  # Draw a polygon on the map if region is None:     region = ee.Geometry.BBox(-99.957, 46.8947, -99.278, 47.1531) vis_params = {\"min\": 0.0, \"max\": 100.0, \"palette\": [\"ffffff\", \"ffbbbb\", \"0000ff\"]} Map.addLayer(image, vis_params, \"Occurrence\") Map.addLayer(region, {}, \"ROI\", True, 0.5) Map.centerObject(region) Map.add_colorbar(vis_params, label=\"Water occurrence (%)\", layer_name=\"Occurrence\") In\u00a0[80]: Copied! <pre>df = geemap.image_histogram(\n    image,\n    region,\n    scale=30,\n    return_df=True,\n)\ndf\n</pre> df = geemap.image_histogram(     image,     region,     scale=30,     return_df=True, ) df Out[80]: key value 0 0 7.007843 1 1 67.749020 2 2 181.384314 3 3 223.658824 4 4 262.384314 ... ... ... 95 95 22259.713725 96 96 28187.235294 97 97 15168.403922 98 98 1817.615686 99 99 13.886275 <p>100 rows \u00d7 2 columns</p> In\u00a0[81]: Copied! <pre>hist = geemap.image_histogram(\n    image,\n    region,\n    scale=30,\n    x_label=\"Water Occurrence (%)\",\n    y_label=\"Pixel Count\",\n    title=\"Surface Water Occurrence\",\n    layout_args={\"title\": dict(x=0.5)},\n    return_df=False,\n)\nhist\n</pre> hist = geemap.image_histogram(     image,     region,     scale=30,     x_label=\"Water Occurrence (%)\",     y_label=\"Pixel Count\",     title=\"Surface Water Occurrence\",     layout_args={\"title\": dict(x=0.5)},     return_df=False, ) hist In\u00a0[82]: Copied! <pre>hist.update_layout(\n    autosize=False, width=800, height=400, margin=dict(l=30, r=20, b=10, t=50, pad=4)\n)\n</pre> hist.update_layout(     autosize=False, width=800, height=400, margin=dict(l=30, r=20, b=10, t=50, pad=4) ) In\u00a0[83]: Copied! <pre>dataset = ee.ImageCollection(\"JRC/GSW1_4/MonthlyHistory\")\ndataset.size()\n</pre> dataset = ee.ImageCollection(\"JRC/GSW1_4/MonthlyHistory\") dataset.size() Out[83]: <ul><li>454</li></ul> In\u00a0[84]: Copied! <pre>dataset.aggregate_array(\"system:index\")\n</pre> dataset.aggregate_array(\"system:index\") Out[84]: <ul><li>List (454 elements)<ul><li>0:1984_03</li><li>1:1984_04</li><li>2:1984_05</li><li>3:1984_06</li><li>4:1984_07</li><li>5:1984_08</li><li>6:1984_09</li><li>7:1984_10</li><li>8:1984_11</li><li>9:1984_12</li><li>10:1985_01</li><li>11:1985_02</li><li>12:1985_03</li><li>13:1985_04</li><li>14:1985_05</li><li>15:1985_06</li><li>16:1985_07</li><li>17:1985_08</li><li>18:1985_09</li><li>19:1985_10</li><li>20:1985_11</li><li>21:1985_12</li><li>22:1986_01</li><li>23:1986_02</li><li>24:1986_03</li><li>25:1986_04</li><li>26:1986_05</li><li>27:1986_06</li><li>28:1986_07</li><li>29:1986_08</li><li>30:1986_09</li><li>31:1986_10</li><li>32:1986_11</li><li>33:1986_12</li><li>34:1987_01</li><li>35:1987_02</li><li>36:1987_03</li><li>37:1987_04</li><li>38:1987_05</li><li>39:1987_06</li><li>40:1987_07</li><li>41:1987_08</li><li>42:1987_09</li><li>43:1987_10</li><li>44:1987_11</li><li>45:1987_12</li><li>46:1988_01</li><li>47:1988_02</li><li>48:1988_03</li><li>49:1988_04</li><li>50:1988_05</li><li>51:1988_06</li><li>52:1988_07</li><li>53:1988_08</li><li>54:1988_09</li><li>55:1988_10</li><li>56:1988_11</li><li>57:1988_12</li><li>58:1989_01</li><li>59:1989_02</li><li>60:1989_03</li><li>61:1989_04</li><li>62:1989_05</li><li>63:1989_06</li><li>64:1989_07</li><li>65:1989_08</li><li>66:1989_09</li><li>67:1989_10</li><li>68:1989_11</li><li>69:1989_12</li><li>70:1990_01</li><li>71:1990_02</li><li>72:1990_03</li><li>73:1990_04</li><li>74:1990_05</li><li>75:1990_06</li><li>76:1990_07</li><li>77:1990_08</li><li>78:1990_09</li><li>79:1990_10</li><li>80:1990_11</li><li>81:1990_12</li><li>82:1991_01</li><li>83:1991_02</li><li>84:1991_03</li><li>85:1991_04</li><li>86:1991_05</li><li>87:1991_06</li><li>88:1991_07</li><li>89:1991_08</li><li>90:1991_09</li><li>91:1991_10</li><li>92:1991_11</li><li>93:1991_12</li><li>94:1992_01</li><li>95:1992_02</li><li>96:1992_03</li><li>97:1992_04</li><li>98:1992_05</li><li>99:1992_06</li><li>100:1992_07</li><li>101:1992_08</li><li>102:1992_09</li><li>103:1992_10</li><li>104:1992_11</li><li>105:1992_12</li><li>106:1993_01</li><li>107:1993_02</li><li>108:1993_03</li><li>109:1993_04</li><li>110:1993_05</li><li>111:1993_06</li><li>112:1993_07</li><li>113:1993_08</li><li>114:1993_09</li><li>115:1993_10</li><li>116:1993_11</li><li>117:1993_12</li><li>118:1994_01</li><li>119:1994_02</li><li>120:1994_03</li><li>121:1994_04</li><li>122:1994_05</li><li>123:1994_06</li><li>124:1994_07</li><li>125:1994_08</li><li>126:1994_09</li><li>127:1994_10</li><li>128:1994_11</li><li>129:1994_12</li><li>130:1995_01</li><li>131:1995_02</li><li>132:1995_03</li><li>133:1995_04</li><li>134:1995_05</li><li>135:1995_06</li><li>136:1995_07</li><li>137:1995_08</li><li>138:1995_09</li><li>139:1995_10</li><li>140:1995_11</li><li>141:1995_12</li><li>142:1996_01</li><li>143:1996_02</li><li>144:1996_03</li><li>145:1996_04</li><li>146:1996_05</li><li>147:1996_06</li><li>148:1996_07</li><li>149:1996_08</li><li>150:1996_09</li><li>151:1996_10</li><li>152:1996_11</li><li>153:1996_12</li><li>154:1997_01</li><li>155:1997_02</li><li>156:1997_03</li><li>157:1997_04</li><li>158:1997_05</li><li>159:1997_06</li><li>160:1997_07</li><li>161:1997_08</li><li>162:1997_09</li><li>163:1997_10</li><li>164:1997_11</li><li>165:1997_12</li><li>166:1998_01</li><li>167:1998_02</li><li>168:1998_03</li><li>169:1998_04</li><li>170:1998_05</li><li>171:1998_06</li><li>172:1998_07</li><li>173:1998_08</li><li>174:1998_09</li><li>175:1998_10</li><li>176:1998_11</li><li>177:1998_12</li><li>178:1999_01</li><li>179:1999_02</li><li>180:1999_03</li><li>181:1999_04</li><li>182:1999_05</li><li>183:1999_06</li><li>184:1999_07</li><li>185:1999_08</li><li>186:1999_09</li><li>187:1999_10</li><li>188:1999_11</li><li>189:1999_12</li><li>190:2000_01</li><li>191:2000_02</li><li>192:2000_03</li><li>193:2000_04</li><li>194:2000_05</li><li>195:2000_06</li><li>196:2000_07</li><li>197:2000_08</li><li>198:2000_09</li><li>199:2000_10</li><li>200:2000_11</li><li>201:2000_12</li><li>202:2001_01</li><li>203:2001_02</li><li>204:2001_03</li><li>205:2001_04</li><li>206:2001_05</li><li>207:2001_06</li><li>208:2001_07</li><li>209:2001_08</li><li>210:2001_09</li><li>211:2001_10</li><li>212:2001_11</li><li>213:2001_12</li><li>214:2002_01</li><li>215:2002_02</li><li>216:2002_03</li><li>217:2002_04</li><li>218:2002_05</li><li>219:2002_06</li><li>220:2002_07</li><li>221:2002_08</li><li>222:2002_09</li><li>223:2002_10</li><li>224:2002_11</li><li>225:2002_12</li><li>226:2003_01</li><li>227:2003_02</li><li>228:2003_03</li><li>229:2003_04</li><li>230:2003_05</li><li>231:2003_06</li><li>232:2003_07</li><li>233:2003_08</li><li>234:2003_09</li><li>235:2003_10</li><li>236:2003_11</li><li>237:2003_12</li><li>238:2004_01</li><li>239:2004_02</li><li>240:2004_03</li><li>241:2004_04</li><li>242:2004_05</li><li>243:2004_06</li><li>244:2004_07</li><li>245:2004_08</li><li>246:2004_09</li><li>247:2004_10</li><li>248:2004_11</li><li>249:2004_12</li><li>250:2005_01</li><li>251:2005_02</li><li>252:2005_03</li><li>253:2005_04</li><li>254:2005_05</li><li>255:2005_06</li><li>256:2005_07</li><li>257:2005_08</li><li>258:2005_09</li><li>259:2005_10</li><li>260:2005_11</li><li>261:2005_12</li><li>262:2006_01</li><li>263:2006_02</li><li>264:2006_03</li><li>265:2006_04</li><li>266:2006_05</li><li>267:2006_06</li><li>268:2006_07</li><li>269:2006_08</li><li>270:2006_09</li><li>271:2006_10</li><li>272:2006_11</li><li>273:2006_12</li><li>274:2007_01</li><li>275:2007_02</li><li>276:2007_03</li><li>277:2007_04</li><li>278:2007_05</li><li>279:2007_06</li><li>280:2007_07</li><li>281:2007_08</li><li>282:2007_09</li><li>283:2007_10</li><li>284:2007_11</li><li>285:2007_12</li><li>286:2008_01</li><li>287:2008_02</li><li>288:2008_03</li><li>289:2008_04</li><li>290:2008_05</li><li>291:2008_06</li><li>292:2008_07</li><li>293:2008_08</li><li>294:2008_09</li><li>295:2008_10</li><li>296:2008_11</li><li>297:2008_12</li><li>298:2009_01</li><li>299:2009_02</li><li>300:2009_03</li><li>301:2009_04</li><li>302:2009_05</li><li>303:2009_06</li><li>304:2009_07</li><li>305:2009_08</li><li>306:2009_09</li><li>307:2009_10</li><li>308:2009_11</li><li>309:2009_12</li><li>310:2010_01</li><li>311:2010_02</li><li>312:2010_03</li><li>313:2010_04</li><li>314:2010_05</li><li>315:2010_06</li><li>316:2010_07</li><li>317:2010_08</li><li>318:2010_09</li><li>319:2010_10</li><li>320:2010_11</li><li>321:2010_12</li><li>322:2011_01</li><li>323:2011_02</li><li>324:2011_03</li><li>325:2011_04</li><li>326:2011_05</li><li>327:2011_06</li><li>328:2011_07</li><li>329:2011_08</li><li>330:2011_09</li><li>331:2011_10</li><li>332:2011_11</li><li>333:2011_12</li><li>334:2012_01</li><li>335:2012_02</li><li>336:2012_03</li><li>337:2012_04</li><li>338:2012_05</li><li>339:2012_06</li><li>340:2012_07</li><li>341:2012_08</li><li>342:2012_09</li><li>343:2012_10</li><li>344:2012_11</li><li>345:2012_12</li><li>346:2013_01</li><li>347:2013_02</li><li>348:2013_03</li><li>349:2013_04</li><li>350:2013_05</li><li>351:2013_06</li><li>352:2013_07</li><li>353:2013_08</li><li>354:2013_09</li><li>355:2013_10</li><li>356:2013_11</li><li>357:2013_12</li><li>358:2014_01</li><li>359:2014_02</li><li>360:2014_03</li><li>361:2014_04</li><li>362:2014_05</li><li>363:2014_06</li><li>364:2014_07</li><li>365:2014_08</li><li>366:2014_09</li><li>367:2014_10</li><li>368:2014_11</li><li>369:2014_12</li><li>370:2015_01</li><li>371:2015_02</li><li>372:2015_03</li><li>373:2015_04</li><li>374:2015_05</li><li>375:2015_06</li><li>376:2015_07</li><li>377:2015_08</li><li>378:2015_09</li><li>379:2015_10</li><li>380:2015_11</li><li>381:2015_12</li><li>382:2016_01</li><li>383:2016_02</li><li>384:2016_03</li><li>385:2016_04</li><li>386:2016_05</li><li>387:2016_06</li><li>388:2016_07</li><li>389:2016_08</li><li>390:2016_09</li><li>391:2016_10</li><li>392:2016_11</li><li>393:2016_12</li><li>394:2017_01</li><li>395:2017_02</li><li>396:2017_03</li><li>397:2017_04</li><li>398:2017_05</li><li>399:2017_06</li><li>400:2017_07</li><li>401:2017_08</li><li>402:2017_09</li><li>403:2017_10</li><li>404:2017_11</li><li>405:2017_12</li><li>406:2018_01</li><li>407:2018_02</li><li>408:2018_03</li><li>409:2018_04</li><li>410:2018_05</li><li>411:2018_06</li><li>412:2018_07</li><li>413:2018_08</li><li>414:2018_09</li><li>415:2018_10</li><li>416:2018_11</li><li>417:2018_12</li><li>418:2019_01</li><li>419:2019_02</li><li>420:2019_03</li><li>421:2019_04</li><li>422:2019_05</li><li>423:2019_06</li><li>424:2019_07</li><li>425:2019_08</li><li>426:2019_09</li><li>427:2019_10</li><li>428:2019_11</li><li>429:2019_12</li><li>430:2020_01</li><li>431:2020_02</li><li>432:2020_03</li><li>433:2020_04</li><li>434:2020_05</li><li>435:2020_06</li><li>436:2020_07</li><li>437:2020_08</li><li>438:2020_09</li><li>439:2020_10</li><li>440:2020_11</li><li>441:2020_12</li><li>442:2021_01</li><li>443:2021_02</li><li>444:2021_03</li><li>445:2021_04</li><li>446:2021_05</li><li>447:2021_06</li><li>448:2021_07</li><li>449:2021_08</li><li>450:2021_09</li><li>451:2021_10</li><li>452:2021_11</li><li>453:2021_12</li></ul></li></ul> In\u00a0[85]: Copied! <pre>Map = geemap.Map()\nMap\n</pre> Map = geemap.Map() Map Out[85]: In\u00a0[86]: Copied! <pre>image = dataset.filterDate(\"2020-08-01\", \"2020-09-01\").first()\nregion = Map.user_roi  # Draw a polygon on the map\nif region is None:\n    region = ee.Geometry.BBox(-99.957, 46.8947, -99.278, 47.1531)\nvis_params = {\"min\": 0.0, \"max\": 2.0, \"palette\": [\"ffffff\", \"fffcb8\", \"0905ff\"]}\n\nMap.addLayer(image, vis_params, \"Water\")\nMap.addLayer(region, {}, \"ROI\", True, 0.5)\nMap.centerObject(region)\n</pre> image = dataset.filterDate(\"2020-08-01\", \"2020-09-01\").first() region = Map.user_roi  # Draw a polygon on the map if region is None:     region = ee.Geometry.BBox(-99.957, 46.8947, -99.278, 47.1531) vis_params = {\"min\": 0.0, \"max\": 2.0, \"palette\": [\"ffffff\", \"fffcb8\", \"0905ff\"]}  Map.addLayer(image, vis_params, \"Water\") Map.addLayer(region, {}, \"ROI\", True, 0.5) Map.centerObject(region) In\u00a0[87]: Copied! <pre>geemap.jrc_hist_monthly_history(\n    region=region, scale=30, frequency=\"month\", denominator=1e4, y_label=\"Area (ha)\"\n)\n</pre> geemap.jrc_hist_monthly_history(     region=region, scale=30, frequency=\"month\", denominator=1e4, y_label=\"Area (ha)\" ) In\u00a0[88]: Copied! <pre>geemap.jrc_hist_monthly_history(\n    region=region,\n    start_month=6,\n    end_month=9,\n    scale=30,\n    frequency=\"month\",\n    denominator=1e4,\n    y_label=\"Area (ha)\",\n)\n</pre> geemap.jrc_hist_monthly_history(     region=region,     start_month=6,     end_month=9,     scale=30,     frequency=\"month\",     denominator=1e4,     y_label=\"Area (ha)\", ) In\u00a0[89]: Copied! <pre>geemap.jrc_hist_monthly_history(\n    region=region,\n    start_month=6,\n    end_month=9,\n    scale=30,\n    frequency=\"year\",\n    reducer=\"mean\",\n    denominator=1e4,\n    y_label=\"Area (ha)\",\n)\n</pre> geemap.jrc_hist_monthly_history(     region=region,     start_month=6,     end_month=9,     scale=30,     frequency=\"year\",     reducer=\"mean\",     denominator=1e4,     y_label=\"Area (ha)\", ) <pre>/Users/qswu/mambaforge/envs/geo/lib/python3.9/site-packages/geemap/common.py:13302: FutureWarning:\n\nThe default value of numeric_only in DataFrameGroupBy.mean is deprecated. In a future version, numeric_only will default to False. Either specify numeric_only or select only columns which should be valid for the function.\n\n</pre> In\u00a0[90]: Copied! <pre>geemap.jrc_hist_monthly_history(\n    region=region,\n    start_month=6,\n    end_month=9,\n    scale=30,\n    frequency=\"year\",\n    reducer=\"max\",\n    denominator=1e4,\n    y_label=\"Area (ha)\",\n)\n</pre> geemap.jrc_hist_monthly_history(     region=region,     start_month=6,     end_month=9,     scale=30,     frequency=\"year\",     reducer=\"max\",     denominator=1e4,     y_label=\"Area (ha)\", )"},{"location":"AmericaView_2023/#why-earth-engine-python-api-and-geemap","title":"Why Earth Engine Python API and geemap?\u00b6","text":"<p>Check out the slides here.</p>"},{"location":"AmericaView_2023/#install-packages","title":"Install packages\u00b6","text":""},{"location":"AmericaView_2023/#import-libraries","title":"Import libraries\u00b6","text":""},{"location":"AmericaView_2023/#authenticate-earth-engine","title":"Authenticate Earth Engine\u00b6","text":"<p>You will need to create a Google Cloud Project and enable the Earth Engine API for the project. You can find detailed instructions here.</p>"},{"location":"AmericaView_2023/#create-interactive-maps","title":"Create interactive maps\u00b6","text":"<p>Let's create an interactive map using the <code>ipyleaflet</code> plotting backend. The <code>geemap.Map</code> class inherits from the <code>ipyleaflet.Map</code> class. Therefore, you can use the same syntax to create an interactive map as you would with <code>ipyleaflet.Map</code>.</p>"},{"location":"AmericaView_2023/#adding-basemaps","title":"Adding basemaps\u00b6","text":"<p>There are several ways to add basemaps to a map. You can specify the basemap to use in the <code>basemap</code> keyword argument when creating the map. Alternatively, you can add basemap layers to the map using the <code>add_basemap</code> method. Geemap has hundreds of built-in basemaps available that can be easily added to the map with only one line of code.</p>"},{"location":"AmericaView_2023/#built-in-basemaps","title":"Built-in basemaps\u00b6","text":"<p>Create a map by specifying the basemap to use as follows. For example, the <code>HYBRID</code> basemap represents the Google Satellite Hybrid basemap.</p>"},{"location":"AmericaView_2023/#xyz-tiles","title":"XYZ tiles\u00b6","text":"<p>You can also add XYZ tile layers to the map using the <code>Map.add_tile_layer()</code> method. For example, the following code creates an interactive map and adds the Google Terrain basemap to it:</p>"},{"location":"AmericaView_2023/#wms-tiles","title":"WMS tiles\u00b6","text":"<p>Similarly, you can add WMS tile layers to the map using the <code>Map.add_wms_layer()</code> method. For example, the following code creates an interactive map and adds the National Land Cover Database (NLCD) 2019 basemap to it:</p>"},{"location":"AmericaView_2023/#earth-engine-data-types","title":"Earth Engine data types\u00b6","text":"<p>Earth Engine objects are server-side objects rather than client-side objects, which means that they are not stored locally on your computer. Similar to video streaming services (e.g., YouTube, Netflix, and Hulu), which store videos/movies on their servers, Earth Engine data are stored on the Earth Engine servers. We can stream geospatial data from Earth Engine on-the-fly without having to download the data just like we can watch videos from streaming services using a web browser without having to download the entire video to your computer.</p> <ul> <li>Image: the fundamental raster data type in Earth Engine.</li> <li>ImageCollection: a stack or time-series of images.</li> <li>Geometry: the fundamental vector data type in Earth Engine.</li> <li>Feature: a Geometry with attributes.</li> <li>FeatureCollection: a set of features.</li> </ul>"},{"location":"AmericaView_2023/#image","title":"Image\u00b6","text":"<p>Raster data in Earth Engine are represented as Image objects. Images are composed of one or more bands and each band has its own name, data type, scale, mask and projection. Each image has metadata stored as a set of properties.</p>"},{"location":"AmericaView_2023/#loading-earth-engine-images","title":"Loading Earth Engine images\u00b6","text":""},{"location":"AmericaView_2023/#visualizing-earth-engine-images","title":"Visualizing Earth Engine images\u00b6","text":""},{"location":"AmericaView_2023/#imagecollection","title":"ImageCollection\u00b6","text":"<p>An <code>ImageCollection</code> is a stack or sequence of images. An <code>ImageCollection</code> can be loaded by passing an Earth Engine asset ID into the <code>ImageCollection</code> constructor. You can find <code>ImageCollection</code> IDs in the Earth Engine Data Catalog.</p>"},{"location":"AmericaView_2023/#loading-image-collections","title":"Loading image collections\u00b6","text":"<p>For example, to load the image collection of the Sentinel-2 surface reflectance:</p>"},{"location":"AmericaView_2023/#visualizing-image-collections","title":"Visualizing image collections\u00b6","text":"<p>To visualize an Earth Engine ImageCollection, we need to convert an ImageCollection to an Image by compositing all the images in the collection to a single image representing, for example, the min, max, median, mean or standard deviation of the images. For example, to create a median value image from a collection, use the <code>collection.median()</code> method. Let's create a median image from the Sentinel-2 surface reflectance collection:</p>"},{"location":"AmericaView_2023/#filtering-image-collections","title":"Filtering image collections\u00b6","text":""},{"location":"AmericaView_2023/#featurecollection","title":"FeatureCollection\u00b6","text":"<p>A FeatureCollection is a collection of Features. A FeatureCollection is analogous to a GeoJSON FeatureCollection object, i.e., a collection of features with associated properties/attributes. Data contained in a shapefile can be represented as a FeatureCollection.</p>"},{"location":"AmericaView_2023/#loading-feature-collections","title":"Loading feature collections\u00b6","text":"<p>The Earth Engine Data Catalog hosts a variety of vector datasets (e.g,, US Census data, country boundaries, and more) as feature collections. You can find feature collection IDs by searching the data catalog. For example, to load the TIGER roads data by the U.S. Census Bureau:</p>"},{"location":"AmericaView_2023/#filtering-feature-collections","title":"Filtering feature collections\u00b6","text":""},{"location":"AmericaView_2023/#visualizing-feature-collections","title":"Visualizing feature collections\u00b6","text":""},{"location":"AmericaView_2023/#earth-engine-data-catalog","title":"Earth Engine Data Catalog\u00b6","text":"<p>The Earth Engine Data Catalog hosts a variety of geospatial datasets. As of March 2023, the catalog contains over 1,000 datasets with a total size of over 40 petabytes. Some notable datasets include: Landsat, Sentinel, MODIS, NAIP, etc. For a complete list of datasets in CSV or JSON formats, see the Earth Engine Datasets List.</p>"},{"location":"AmericaView_2023/#searching-for-datasets","title":"Searching for datasets\u00b6","text":"<p>The Earth Engine Data Catalog is searchable. You can search datasets by name, keyword, or tag. For example, enter \"elevation\" in the search box will filter the catalog to show only datasets containing \"elevation\" in their name, description, or tags. 52 datasets are returned for this search query. Scroll down the list to find the NASA SRTM Digital Elevation 30m dataset. On each dataset page, you can find the following information, including Dataset Availability, Dataset Provider, Earth Engine Snippet, Tags, Description, Code Example, and more (see {numref}<code>ch03_gee_srtm</code>). One important piece of information is the Image/ImageCollection/FeatureCollection ID of each dataset, which is essential for accessing the dataset through the Earth Engine JavaScript or Python APIs.</p> <p></p>"},{"location":"AmericaView_2023/#using-the-datasets-module","title":"Using the datasets module\u00b6","text":""},{"location":"AmericaView_2023/#using-the-inspector-tool","title":"Using the inspector tool\u00b6","text":""},{"location":"AmericaView_2023/#converting-javascript-to-python","title":"Converting JavaScript to Python\u00b6","text":"<p>Find some Earth Engine JavaScript code that you want to convert to Python. For example, you can grab some sample code from the Earth Engine Documentation.</p>"},{"location":"AmericaView_2023/#using-the-plotting-tool","title":"Using the plotting tool\u00b6","text":""},{"location":"AmericaView_2023/#creating-legends","title":"Creating legends\u00b6","text":""},{"location":"AmericaView_2023/#built-in-legends","title":"Built-in legends\u00b6","text":""},{"location":"AmericaView_2023/#custom-legends","title":"Custom legends\u00b6","text":""},{"location":"AmericaView_2023/#creating-color-bars","title":"Creating color bars\u00b6","text":""},{"location":"AmericaView_2023/#split-panel-maps","title":"Split-panel maps\u00b6","text":""},{"location":"AmericaView_2023/#linked-maps","title":"Linked maps\u00b6","text":""},{"location":"AmericaView_2023/#timeseries-inspector","title":"Timeseries inspector\u00b6","text":""},{"location":"AmericaView_2023/#time-slider","title":"Time slider\u00b6","text":""},{"location":"AmericaView_2023/#visualizing-vegetation-data","title":"Visualizing vegetation data\u00b6","text":""},{"location":"AmericaView_2023/#visualizing-weather-data","title":"Visualizing weather data\u00b6","text":""},{"location":"AmericaView_2023/#visualizing-sentinel-2-imagery","title":"Visualizing Sentinel-2 imagery\u00b6","text":""},{"location":"AmericaView_2023/#zonal-statistics-with-earth-engine","title":"Zonal statistics with Earth Engine\u00b6","text":""},{"location":"AmericaView_2023/#zonal-statistics","title":"Zonal statistics\u00b6","text":""},{"location":"AmericaView_2023/#zonal-statistics-by-group","title":"Zonal statistics by group\u00b6","text":""},{"location":"AmericaView_2023/#zonal-statistics-with-two-images","title":"Zonal statistics with two images\u00b6","text":""},{"location":"AmericaView_2023/#exporting-images","title":"Exporting images\u00b6","text":""},{"location":"AmericaView_2023/#to-local-drive","title":"To local drive\u00b6","text":""},{"location":"AmericaView_2023/#to-google-drive","title":"To Google Drive\u00b6","text":""},{"location":"AmericaView_2023/#to-asset","title":"To Asset\u00b6","text":""},{"location":"AmericaView_2023/#exporting-image-collections","title":"Exporting image collections\u00b6","text":""},{"location":"AmericaView_2023/#to-local-drive","title":"To local drive\u00b6","text":""},{"location":"AmericaView_2023/#to-google-drive","title":"To Google Drive\u00b6","text":""},{"location":"AmericaView_2023/#exporting-feature-collections","title":"Exporting feature collections\u00b6","text":""},{"location":"AmericaView_2023/#to-local-drive","title":"To local drive\u00b6","text":""},{"location":"AmericaView_2023/#to-google-drive","title":"To Google Drive\u00b6","text":""},{"location":"AmericaView_2023/#creating-timeseries","title":"Creating timeseries\u00b6","text":""},{"location":"AmericaView_2023/#creating-timelapse","title":"Creating timelapse\u00b6","text":""},{"location":"AmericaView_2023/#landsat-timelapse","title":"Landsat timelapse\u00b6","text":""},{"location":"AmericaView_2023/#modis-timelapse","title":"MODIS timelapse\u00b6","text":""},{"location":"AmericaView_2023/#analyzing-surface-water-dynamics","title":"Analyzing surface water dynamics\u00b6","text":""},{"location":"AmericaView_2023/#surface-water-occurrence","title":"Surface water occurrence\u00b6","text":""},{"location":"AmericaView_2023/#surface-water-monthly-history","title":"Surface water monthly history\u00b6","text":""},{"location":"brazil_floods/","title":"Brazil floods","text":"In\u00a0[1]: Copied! <pre># !pip install geemap\n</pre> # !pip install geemap In\u00a0[2]: Copied! <pre>import ee\nimport geemap.foliumap as geemap\n</pre> import ee import geemap.foliumap as geemap In\u00a0[3]: Copied! <pre>geemap.ee_initialize()\n</pre> geemap.ee_initialize() In\u00a0[4]: Copied! <pre>url = \"https://github.com/opengeos/datasets/releases/download/places/Rio_Grande_do_Sul_Brazil.geojson\"\n</pre> url = \"https://github.com/opengeos/datasets/releases/download/places/Rio_Grande_do_Sul_Brazil.geojson\" In\u00a0[5]: Copied! <pre>roi = geemap.geojson_to_ee(url)\n# roi\n</pre> roi = geemap.geojson_to_ee(url) # roi <pre>Downloading...\nFrom: https://github.com/opengeos/datasets/releases/download/places/Rio_Grande_do_Sul_Brazil.geojson\nTo: /tmp/90658649-b46b-4c70-8fba-684ecd9a404b.geojson\n100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 61.2k/61.2k [00:00&lt;00:00, 2.14MB/s]\n</pre> In\u00a0[6]: Copied! <pre>centroid = roi.geometry().centroid(1)\nlon, lat = centroid.getInfo()[\"coordinates\"]\nprint(f\"Longitude: {lon}, Latitude: {lat}\")\n</pre> centroid = roi.geometry().centroid(1) lon, lat = centroid.getInfo()[\"coordinates\"] print(f\"Longitude: {lon}, Latitude: {lat}\") <pre>Longitude: -53.2453436538024, Latitude: -29.778651228599525\n</pre> In\u00a0[7]: Copied! <pre>m = geemap.Map()\nstyle = {\"fillColor\": \"00000000\", \"color\": \"FF0000\"}\nm.add_layer(roi.style(**style), {}, \"ROI\")\ngeom = roi.geometry()\nm.center_object(geom, 6)\nm\n</pre> m = geemap.Map() style = {\"fillColor\": \"00000000\", \"color\": \"FF0000\"} m.add_layer(roi.style(**style), {}, \"ROI\") geom = roi.geometry() m.center_object(geom, 6) m Out[7]: <p>In the tutorial, we will focus on  Rio Grande do Sul in Brazil, but the code can be easily modified to visualize and analyze floods in other countries. Modify the <code>place_name</code> variable to specify the place of interest and set the date range for the flood event. In order to extract the flood extent, we also need to specify the date range for the pre-flood period.</p> In\u00a0[8]: Copied! <pre>place_name = \"Rio Grande do Sul\"\npre_flood_start_date = \"2024-01-01\"\npre_flood_end_date = \"2024-04-27\"\npost_flood_start_date = \"2024-04-29\"\npost_flood_end_date = \"2024-05-17\"\n</pre> place_name = \"Rio Grande do Sul\" pre_flood_start_date = \"2024-01-01\" pre_flood_end_date = \"2024-04-27\" post_flood_start_date = \"2024-04-29\" post_flood_end_date = \"2024-05-17\" In\u00a0[9]: Copied! <pre>pre_flood_col = (\n    ee.ImageCollection(\"NASA/HLS/HLSL30/v002\")\n    .filterBounds(roi)\n    .filterDate(pre_flood_start_date, pre_flood_end_date)\n    .filter(ee.Filter.lt(\"CLOUD_COVERAGE\", 15))\n)\nprint(\n    f\"The number of images in the pre-flood collection: {pre_flood_col.size().getInfo()}\"\n)\n</pre> pre_flood_col = (     ee.ImageCollection(\"NASA/HLS/HLSL30/v002\")     .filterBounds(roi)     .filterDate(pre_flood_start_date, pre_flood_end_date)     .filter(ee.Filter.lt(\"CLOUD_COVERAGE\", 15)) ) print(     f\"The number of images in the pre-flood collection: {pre_flood_col.size().getInfo()}\" ) <pre>The number of images in the pre-flood collection: 374\n</pre> In\u00a0[10]: Copied! <pre>post_flood_col = (\n    ee.ImageCollection(\"NASA/HLS/HLSL30/v002\")\n    .filterBounds(roi)\n    .filterDate(post_flood_start_date, post_flood_end_date)\n    .filter(ee.Filter.lt(\"CLOUD_COVERAGE\", 50))\n)\nprint(\n    f\"The number of images in the post-flood collection: {post_flood_col.size().getInfo()}\"\n)\n</pre> post_flood_col = (     ee.ImageCollection(\"NASA/HLS/HLSL30/v002\")     .filterBounds(roi)     .filterDate(post_flood_start_date, post_flood_end_date)     .filter(ee.Filter.lt(\"CLOUD_COVERAGE\", 50)) ) print(     f\"The number of images in the post-flood collection: {post_flood_col.size().getInfo()}\" ) <pre>The number of images in the post-flood collection: 34\n</pre> <p>Visualize the Landsat 8 composite for the pre-flood and flood periods.</p> In\u00a0[11]: Copied! <pre>m = geemap.Map()\n\npre_flood_image = pre_flood_col.median().clipToCollection(roi)\npost_flood_image = post_flood_col.median().clipToCollection(roi)\n\nvis_params = {\"bands\": [\"B6\", \"B5\", \"B4\"], \"min\": 0, \"max\": 0.4}\nm.add_layer(pre_flood_image, vis_params, \"Landsat Pre-flood\")\nm.add_layer(post_flood_image, vis_params, \"Landsat Post-flood\")\nm.add_layer(roi.style(**style), {}, place_name)\nm.center_object(roi, 6)\nm\n</pre> m = geemap.Map()  pre_flood_image = pre_flood_col.median().clipToCollection(roi) post_flood_image = post_flood_col.median().clipToCollection(roi)  vis_params = {\"bands\": [\"B6\", \"B5\", \"B4\"], \"min\": 0, \"max\": 0.4} m.add_layer(pre_flood_image, vis_params, \"Landsat Pre-flood\") m.add_layer(post_flood_image, vis_params, \"Landsat Post-flood\") m.add_layer(roi.style(**style), {}, place_name) m.center_object(roi, 6) m Out[11]: In\u00a0[12]: Copied! <pre>m = geemap.Map()\nleft_layer = geemap.ee_tile_layer(pre_flood_image, vis_params, \"Landsat Pre-flood\")\nright_layer = geemap.ee_tile_layer(post_flood_image, vis_params, \"Landsat Post-flood\")\nm.split_map(\n    left_layer,\n    right_layer,\n    left_label=\"Landsat Pre-flood\",\n    right_label=\"Landsat Post-flood\",\n)\nm.add_layer(roi.style(**style), {}, place_name)\nm.center_object(roi, 6)\nm\n</pre> m = geemap.Map() left_layer = geemap.ee_tile_layer(pre_flood_image, vis_params, \"Landsat Pre-flood\") right_layer = geemap.ee_tile_layer(post_flood_image, vis_params, \"Landsat Post-flood\") m.split_map(     left_layer,     right_layer,     left_label=\"Landsat Pre-flood\",     right_label=\"Landsat Post-flood\", ) m.add_layer(roi.style(**style), {}, place_name) m.center_object(roi, 6) m Out[12]: In\u00a0[13]: Copied! <pre>ndwi_pre = pre_flood_image.normalizedDifference([\"B3\", \"B5\"]).rename(\"NDWI\")\nndwi_post = post_flood_image.normalizedDifference([\"B3\", \"B5\"]).rename(\"NDWI\")\n</pre> ndwi_pre = pre_flood_image.normalizedDifference([\"B3\", \"B5\"]).rename(\"NDWI\") ndwi_post = post_flood_image.normalizedDifference([\"B3\", \"B5\"]).rename(\"NDWI\") <p>Compute the NDWI layers for the pre-flood and flood periods side by side.</p> In\u00a0[14]: Copied! <pre>m = geemap.Map()\nndwi_vis = {\"min\": -1, \"max\": 1, \"palette\": \"ndwi\"}\nleft_layer = geemap.ee_tile_layer(ndwi_pre, ndwi_vis, \"NDWI Pre-flood\")\nright_layer = geemap.ee_tile_layer(ndwi_post, ndwi_vis, \"NDWI Post-flood\")\nm.split_map(\n    left_layer, right_layer, left_label=\"NDWI Pre-flood\", right_label=\"NDWI Post-flood\"\n)\nm.add_layer(roi.style(**style), {}, place_name)\nm.center_object(roi, 6)\nm\n</pre> m = geemap.Map() ndwi_vis = {\"min\": -1, \"max\": 1, \"palette\": \"ndwi\"} left_layer = geemap.ee_tile_layer(ndwi_pre, ndwi_vis, \"NDWI Pre-flood\") right_layer = geemap.ee_tile_layer(ndwi_post, ndwi_vis, \"NDWI Post-flood\") m.split_map(     left_layer, right_layer, left_label=\"NDWI Pre-flood\", right_label=\"NDWI Post-flood\" ) m.add_layer(roi.style(**style), {}, place_name) m.center_object(roi, 6) m Out[14]: In\u00a0[15]: Copied! <pre>threshold = 0.1\nwater_pre = ndwi_pre.gt(threshold)\nwater_post = ndwi_post.gt(threshold)\n</pre> threshold = 0.1 water_pre = ndwi_pre.gt(threshold) water_post = ndwi_post.gt(threshold) <p>Combine the pre-flood and surface water extent side by side.</p> In\u00a0[16]: Copied! <pre>m = geemap.Map()\n\nm.add_layer(pre_flood_image, vis_params, \"Landsat Pre-flood\", True)\nm.add_layer(post_flood_image, vis_params, \"Landsat Post-flood\", True)\n\nleft_layer = geemap.ee_tile_layer(\n    water_pre.selfMask(), {\"palette\": \"blue\"}, \"Water Pre-flood\"\n)\nright_layer = geemap.ee_tile_layer(\n    water_post.selfMask(), {\"palette\": \"red\"}, \"Water Post-flood\"\n)\n\nm.split_map(\n    left_layer,\n    right_layer,\n    left_label=\"Water Pre-flood\",\n    right_label=\"Water Post-flood\",\n)\nm.add_layer(roi.style(**style), {}, place_name)\nm.center_object(roi, 6)\nm\n</pre> m = geemap.Map()  m.add_layer(pre_flood_image, vis_params, \"Landsat Pre-flood\", True) m.add_layer(post_flood_image, vis_params, \"Landsat Post-flood\", True)  left_layer = geemap.ee_tile_layer(     water_pre.selfMask(), {\"palette\": \"blue\"}, \"Water Pre-flood\" ) right_layer = geemap.ee_tile_layer(     water_post.selfMask(), {\"palette\": \"red\"}, \"Water Post-flood\" )  m.split_map(     left_layer,     right_layer,     left_label=\"Water Pre-flood\",     right_label=\"Water Post-flood\", ) m.add_layer(roi.style(**style), {}, place_name) m.center_object(roi, 6) m Out[16]: In\u00a0[17]: Copied! <pre>flood_extent = water_post.subtract(water_pre).gt(0).selfMask()\n</pre> flood_extent = water_post.subtract(water_pre).gt(0).selfMask() <p>Add the flood extent layer to the map.</p> In\u00a0[18]: Copied! <pre>m = geemap.Map()\n\nm.add_layer(pre_flood_image, vis_params, \"Landsat Pre-flood\", True)\nm.add_layer(post_flood_image, vis_params, \"Landsat Post-flood\", True)\n\nleft_layer = geemap.ee_tile_layer(\n    water_pre.selfMask(), {\"palette\": \"blue\"}, \"Water Pre-flood\"\n)\nright_layer = geemap.ee_tile_layer(\n    water_post.selfMask(), {\"palette\": \"red\"}, \"Water Post-flood\"\n)\n\nm.split_map(\n    left_layer,\n    right_layer,\n    left_label=\"Water Pre-flood\",\n    right_label=\"Water Post-flood\",\n)\n\nm.add_layer(flood_extent, {\"palette\": \"cyan\"}, \"Flood Extent\")\nm.add_layer(roi.style(**style), {}, place_name)\nm.center_object(roi, 6)\nm\n</pre> m = geemap.Map()  m.add_layer(pre_flood_image, vis_params, \"Landsat Pre-flood\", True) m.add_layer(post_flood_image, vis_params, \"Landsat Post-flood\", True)  left_layer = geemap.ee_tile_layer(     water_pre.selfMask(), {\"palette\": \"blue\"}, \"Water Pre-flood\" ) right_layer = geemap.ee_tile_layer(     water_post.selfMask(), {\"palette\": \"red\"}, \"Water Post-flood\" )  m.split_map(     left_layer,     right_layer,     left_label=\"Water Pre-flood\",     right_label=\"Water Post-flood\", )  m.add_layer(flood_extent, {\"palette\": \"cyan\"}, \"Flood Extent\") m.add_layer(roi.style(**style), {}, place_name) m.center_object(roi, 6) m Out[18]: In\u00a0[19]: Copied! <pre>area_pre_flood = geemap.zonal_stats(\n    water_pre.selfMask(), roi, scale=1000, stat_type=\"SUM\", return_fc=True\n)\ngeemap.ee_to_df(area_pre_flood)\n</pre> area_pre_flood = geemap.zonal_stats(     water_pre.selfMask(), roi, scale=1000, stat_type=\"SUM\", return_fc=True ) geemap.ee_to_df(area_pre_flood) <pre>Computing statistics ...\n</pre> Out[19]: area_1 area_tot_g codigo geocodigo mapid mslink nome perimetro_ sum 0 281748.155 281748.155 43 43 99 223 RIO GRANDE DO SUL 3524.58571 16801.019608 In\u00a0[20]: Copied! <pre>area_2022 = geemap.zonal_stats(\n    water_post.selfMask(), roi, scale=1000, stat_type=\"SUM\", return_fc=True\n)\ngeemap.ee_to_df(area_2022)\n</pre> area_2022 = geemap.zonal_stats(     water_post.selfMask(), roi, scale=1000, stat_type=\"SUM\", return_fc=True ) geemap.ee_to_df(area_2022) <pre>Computing statistics ...\n</pre> Out[20]: area_1 area_tot_g codigo geocodigo mapid mslink nome perimetro_ sum 0 281748.155 281748.155 43 43 99 223 RIO GRANDE DO SUL 3524.58571 1884.207843 In\u00a0[21]: Copied! <pre>flood_area = geemap.zonal_stats(\n    flood_extent.selfMask(), roi, scale=1000, stat_type=\"SUM\", return_fc=True\n)\ngeemap.ee_to_df(flood_area)\n</pre> flood_area = geemap.zonal_stats(     flood_extent.selfMask(), roi, scale=1000, stat_type=\"SUM\", return_fc=True ) geemap.ee_to_df(flood_area) <pre>Computing statistics ...\n</pre> Out[21]: area_1 area_tot_g codigo geocodigo mapid mslink nome perimetro_ sum 0 281748.155 281748.155 43 43 99 223 RIO GRANDE DO SUL 3524.58571 634.188235 In\u00a0[22]: Copied! <pre>pre_flood_start_date = \"2023-10-01\"\npre_flood_end_date = \"2024-04-27\"\npost_flood_start_date = \"2024-04-29\"\npost_flood_end_date = \"2024-05-17\"\n</pre> pre_flood_start_date = \"2023-10-01\" pre_flood_end_date = \"2024-04-27\" post_flood_start_date = \"2024-04-29\" post_flood_end_date = \"2024-05-17\" In\u00a0[23]: Copied! <pre>s1_col_pre = (\n    ee.ImageCollection(\"COPERNICUS/S1_GRD\")\n    .filter(ee.Filter.listContains(\"transmitterReceiverPolarisation\", \"VV\"))\n    .filter(ee.Filter.eq(\"instrumentMode\", \"IW\"))\n    .filterDate(pre_flood_start_date, pre_flood_end_date)\n    .filterBounds(roi)\n    .select(\"VV\")\n)\nprint(\n    f\"The number of images in the pre-flood collection: {s1_col_pre.size().getInfo()}\"\n)\n</pre> s1_col_pre = (     ee.ImageCollection(\"COPERNICUS/S1_GRD\")     .filter(ee.Filter.listContains(\"transmitterReceiverPolarisation\", \"VV\"))     .filter(ee.Filter.eq(\"instrumentMode\", \"IW\"))     .filterDate(pre_flood_start_date, pre_flood_end_date)     .filterBounds(roi)     .select(\"VV\") ) print(     f\"The number of images in the pre-flood collection: {s1_col_pre.size().getInfo()}\" ) <pre>The number of images in the pre-flood collection: 161\n</pre> <p>Create the Sentinel-1 image collection for the flood period.</p> In\u00a0[24]: Copied! <pre>s1_col_post = (\n    ee.ImageCollection(\"COPERNICUS/S1_GRD\")\n    .filter(ee.Filter.listContains(\"transmitterReceiverPolarisation\", \"VV\"))\n    .filter(ee.Filter.eq(\"instrumentMode\", \"IW\"))\n    # .filter(ee.Filter.eq('orbitProperties_pass', 'ASCENDING'))\n    .filterDate(post_flood_start_date, post_flood_end_date)\n    .filterBounds(roi)\n    .select(\"VV\")\n)\nprint(\n    f\"The number of images in the post-flood collection: {s1_col_post.size().getInfo()}\"\n)\n</pre> s1_col_post = (     ee.ImageCollection(\"COPERNICUS/S1_GRD\")     .filter(ee.Filter.listContains(\"transmitterReceiverPolarisation\", \"VV\"))     .filter(ee.Filter.eq(\"instrumentMode\", \"IW\"))     # .filter(ee.Filter.eq('orbitProperties_pass', 'ASCENDING'))     .filterDate(post_flood_start_date, post_flood_end_date)     .filterBounds(roi)     .select(\"VV\") ) print(     f\"The number of images in the post-flood collection: {s1_col_post.size().getInfo()}\" ) <pre>The number of images in the post-flood collection: 19\n</pre> <p>Create Sentinel-1 SAR composites for the pre-flood and flood periods.</p> In\u00a0[25]: Copied! <pre>m = geemap.Map()\nm.add_basemap(\"Esri.WorldImagery\")\nsar_pre = s1_col_pre.reduce(ee.Reducer.percentile([20])).clipToCollection(roi)\nsar_post = s1_col_post.reduce(ee.Reducer.percentile([20])).clipToCollection(roi)\nm.add_layer(sar_pre, {\"min\": -25, \"max\": -5}, \"SAR Pre-flood\")\nm.add_layer(sar_post, {\"min\": -25, \"max\": -5}, \"SAR Post-flood\")\nm.add_layer(roi.style(**style), {}, place_name)\nm.center_object(roi, 6)\nm\n</pre> m = geemap.Map() m.add_basemap(\"Esri.WorldImagery\") sar_pre = s1_col_pre.reduce(ee.Reducer.percentile([20])).clipToCollection(roi) sar_post = s1_col_post.reduce(ee.Reducer.percentile([20])).clipToCollection(roi) m.add_layer(sar_pre, {\"min\": -25, \"max\": -5}, \"SAR Pre-flood\") m.add_layer(sar_post, {\"min\": -25, \"max\": -5}, \"SAR Post-flood\") m.add_layer(roi.style(**style), {}, place_name) m.center_object(roi, 6) m <pre>Basemap can only be one of the following: OpenStreetMap, ROADMAP, SATELLITE, TERRAIN, HYBRID, FWS NWI Wetlands, FWS NWI Wetlands Raster, NLCD 2021 CONUS Land Cover, NLCD 2019 CONUS Land Cover, NLCD 2016 CONUS Land Cover, NLCD 2013 CONUS Land Cover, NLCD 2011 CONUS Land Cover, NLCD 2008 CONUS Land Cover, NLCD 2006 CONUS Land Cover, NLCD 2004 CONUS Land Cover, NLCD 2001 CONUS Land Cover, USGS NAIP Imagery, USGS NAIP Imagery False Color, USGS NAIP Imagery NDVI, USGS Hydrography, USGS 3DEP Elevation, ESA WorldCover 2020, ESA WorldCover 2020 S2 FCC, ESA WorldCover 2020 S2 TCC, ESA WorldCover 2021, ESA WorldCover 2021 S2 FCC, ESA WorldCover 2021 S2 TCC, BaseMapDE.Color, BaseMapDE.Grey, BasemapAT.basemap, BasemapAT.grau, BasemapAT.highdpi, BasemapAT.orthofoto, BasemapAT.overlay, BasemapAT.surface, BasemapAT.terrain, CartoDB.DarkMatter, CartoDB.DarkMatterNoLabels, CartoDB.DarkMatterOnlyLabels, CartoDB.Positron, CartoDB.PositronNoLabels, CartoDB.PositronOnlyLabels, CartoDB.Voyager, CartoDB.VoyagerLabelsUnder, CartoDB.VoyagerNoLabels, CartoDB.VoyagerOnlyLabels, CyclOSM, Esri.AntarcticBasemap, Esri.AntarcticImagery, Esri.ArcticImagery, Esri.ArcticOceanBase, Esri.ArcticOceanReference, Esri.DeLorme, Esri.NatGeoWorldMap, Esri.OceanBasemap, Esri.WorldGrayCanvas, Esri.WorldPhysical, Esri.WorldShadedRelief, Esri.WorldTerrain, FreeMapSK, Gaode.Normal, Gaode.Satellite, HikeBike.HikeBike, HikeBike.HillShading, JusticeMap.americanIndian, JusticeMap.asian, JusticeMap.black, JusticeMap.hispanic, JusticeMap.income, JusticeMap.multi, JusticeMap.nonWhite, JusticeMap.plurality, JusticeMap.white, MtbMap, NASAGIBS.ASTER_GDEM_Greyscale_Shaded_Relief, NASAGIBS.BlueMarble3031, NASAGIBS.BlueMarble3413, NASAGIBS.ModisAquaBands721CR, NASAGIBS.ModisAquaTrueColorCR, NASAGIBS.ModisTerraAOD, NASAGIBS.ModisTerraBands367CR, NASAGIBS.ModisTerraBands721CR, NASAGIBS.ModisTerraChlorophyll, NASAGIBS.ModisTerraLSTDay, NASAGIBS.ModisTerraSnowCover, NASAGIBS.ModisTerraTrueColorCR, NASAGIBS.ViirsEarthAtNight2012, NASAGIBS.ViirsTrueColorCR, OPNVKarte, OneMapSG.Default, OneMapSG.Grey, OneMapSG.LandLot, OneMapSG.Night, OneMapSG.Original, OpenAIP, OpenFireMap, OpenRailwayMap, OpenSeaMap, OpenSnowMap.pistes, OpenStreetMap.BZH, OpenStreetMap.BlackAndWhite, OpenStreetMap.CH, OpenStreetMap.DE, OpenStreetMap.HOT, OpenStreetMap.Mapnik, OpenTopoMap, SafeCast, Stadia.AlidadeSmooth, Stadia.AlidadeSmoothDark, Stadia.OSMBright, Stadia.Outdoors, Stadia.StamenTerrain, Stadia.StamenTerrainBackground, Stadia.StamenTerrainLabels, Stadia.StamenTerrainLines, Stadia.StamenToner, Stadia.StamenTonerBackground, Stadia.StamenTonerLabels, Stadia.StamenTonerLines, Stadia.StamenTonerLite, Stadia.StamenWatercolor, Strava.All, Strava.Ride, Strava.Run, Strava.Water, Strava.Winter, SwissFederalGeoportal.JourneyThroughTime, SwissFederalGeoportal.NationalMapColor, SwissFederalGeoportal.NationalMapGrey, SwissFederalGeoportal.SWISSIMAGE, TopPlusOpen.Color, TopPlusOpen.Grey, USGS.USImagery, USGS.USImageryTopo, USGS.USTopo, WaymarkedTrails.cycling, WaymarkedTrails.hiking, WaymarkedTrails.mtb, WaymarkedTrails.riding, WaymarkedTrails.skating, WaymarkedTrails.slopes, nlmaps.grijs, nlmaps.luchtfoto, nlmaps.pastel, nlmaps.standaard, nlmaps.water\n</pre> Out[25]: In\u00a0[26]: Copied! <pre>s1_col_pre = s1_col_pre.map(lambda img: img.focal_median(100, \"circle\", \"meters\"))\ns1_col_post = s1_col_post.map(lambda img: img.focal_median(100, \"circle\", \"meters\"))\n</pre> s1_col_pre = s1_col_pre.map(lambda img: img.focal_median(100, \"circle\", \"meters\")) s1_col_post = s1_col_post.map(lambda img: img.focal_median(100, \"circle\", \"meters\")) In\u00a0[27]: Copied! <pre>m = geemap.Map()\nm.add_basemap(\"Esri.WorldImagery\")\nsar_pre = s1_col_pre.reduce(ee.Reducer.percentile([20])).clipToCollection(roi)\nsar_post = s1_col_post.reduce(ee.Reducer.percentile([20])).clipToCollection(roi)\nm.add_layer(sar_pre, {\"min\": -25, \"max\": -5}, \"SAR Pre-flood\")\nm.add_layer(sar_post, {\"min\": -25, \"max\": -5}, \"SAR Post-flood\")\nm.add_layer(roi.style(**style), {}, place_name)\nm.center_object(roi, 6)\nm\n</pre> m = geemap.Map() m.add_basemap(\"Esri.WorldImagery\") sar_pre = s1_col_pre.reduce(ee.Reducer.percentile([20])).clipToCollection(roi) sar_post = s1_col_post.reduce(ee.Reducer.percentile([20])).clipToCollection(roi) m.add_layer(sar_pre, {\"min\": -25, \"max\": -5}, \"SAR Pre-flood\") m.add_layer(sar_post, {\"min\": -25, \"max\": -5}, \"SAR Post-flood\") m.add_layer(roi.style(**style), {}, place_name) m.center_object(roi, 6) m <pre>Basemap can only be one of the following: OpenStreetMap, ROADMAP, SATELLITE, TERRAIN, HYBRID, FWS NWI Wetlands, FWS NWI Wetlands Raster, NLCD 2021 CONUS Land Cover, NLCD 2019 CONUS Land Cover, NLCD 2016 CONUS Land Cover, NLCD 2013 CONUS Land Cover, NLCD 2011 CONUS Land Cover, NLCD 2008 CONUS Land Cover, NLCD 2006 CONUS Land Cover, NLCD 2004 CONUS Land Cover, NLCD 2001 CONUS Land Cover, USGS NAIP Imagery, USGS NAIP Imagery False Color, USGS NAIP Imagery NDVI, USGS Hydrography, USGS 3DEP Elevation, ESA WorldCover 2020, ESA WorldCover 2020 S2 FCC, ESA WorldCover 2020 S2 TCC, ESA WorldCover 2021, ESA WorldCover 2021 S2 FCC, ESA WorldCover 2021 S2 TCC, BaseMapDE.Color, BaseMapDE.Grey, BasemapAT.basemap, BasemapAT.grau, BasemapAT.highdpi, BasemapAT.orthofoto, BasemapAT.overlay, BasemapAT.surface, BasemapAT.terrain, CartoDB.DarkMatter, CartoDB.DarkMatterNoLabels, CartoDB.DarkMatterOnlyLabels, CartoDB.Positron, CartoDB.PositronNoLabels, CartoDB.PositronOnlyLabels, CartoDB.Voyager, CartoDB.VoyagerLabelsUnder, CartoDB.VoyagerNoLabels, CartoDB.VoyagerOnlyLabels, CyclOSM, Esri.AntarcticBasemap, Esri.AntarcticImagery, Esri.ArcticImagery, Esri.ArcticOceanBase, Esri.ArcticOceanReference, Esri.DeLorme, Esri.NatGeoWorldMap, Esri.OceanBasemap, Esri.WorldGrayCanvas, Esri.WorldPhysical, Esri.WorldShadedRelief, Esri.WorldTerrain, FreeMapSK, Gaode.Normal, Gaode.Satellite, HikeBike.HikeBike, HikeBike.HillShading, JusticeMap.americanIndian, JusticeMap.asian, JusticeMap.black, JusticeMap.hispanic, JusticeMap.income, JusticeMap.multi, JusticeMap.nonWhite, JusticeMap.plurality, JusticeMap.white, MtbMap, NASAGIBS.ASTER_GDEM_Greyscale_Shaded_Relief, NASAGIBS.BlueMarble3031, NASAGIBS.BlueMarble3413, NASAGIBS.ModisAquaBands721CR, NASAGIBS.ModisAquaTrueColorCR, NASAGIBS.ModisTerraAOD, NASAGIBS.ModisTerraBands367CR, NASAGIBS.ModisTerraBands721CR, NASAGIBS.ModisTerraChlorophyll, NASAGIBS.ModisTerraLSTDay, NASAGIBS.ModisTerraSnowCover, NASAGIBS.ModisTerraTrueColorCR, NASAGIBS.ViirsEarthAtNight2012, NASAGIBS.ViirsTrueColorCR, OPNVKarte, OneMapSG.Default, OneMapSG.Grey, OneMapSG.LandLot, OneMapSG.Night, OneMapSG.Original, OpenAIP, OpenFireMap, OpenRailwayMap, OpenSeaMap, OpenSnowMap.pistes, OpenStreetMap.BZH, OpenStreetMap.BlackAndWhite, OpenStreetMap.CH, OpenStreetMap.DE, OpenStreetMap.HOT, OpenStreetMap.Mapnik, OpenTopoMap, SafeCast, Stadia.AlidadeSmooth, Stadia.AlidadeSmoothDark, Stadia.OSMBright, Stadia.Outdoors, Stadia.StamenTerrain, Stadia.StamenTerrainBackground, Stadia.StamenTerrainLabels, Stadia.StamenTerrainLines, Stadia.StamenToner, Stadia.StamenTonerBackground, Stadia.StamenTonerLabels, Stadia.StamenTonerLines, Stadia.StamenTonerLite, Stadia.StamenWatercolor, Strava.All, Strava.Ride, Strava.Run, Strava.Water, Strava.Winter, SwissFederalGeoportal.JourneyThroughTime, SwissFederalGeoportal.NationalMapColor, SwissFederalGeoportal.NationalMapGrey, SwissFederalGeoportal.SWISSIMAGE, TopPlusOpen.Color, TopPlusOpen.Grey, USGS.USImagery, USGS.USImageryTopo, USGS.USTopo, WaymarkedTrails.cycling, WaymarkedTrails.hiking, WaymarkedTrails.mtb, WaymarkedTrails.riding, WaymarkedTrails.skating, WaymarkedTrails.slopes, nlmaps.grijs, nlmaps.luchtfoto, nlmaps.pastel, nlmaps.standaard, nlmaps.water\n</pre> Out[27]: In\u00a0[28]: Copied! <pre>m = geemap.Map()\nleft_layer = geemap.ee_tile_layer(sar_pre, {\"min\": -25, \"max\": -5}, \"SAR Pre-flood\")\nright_layer = geemap.ee_tile_layer(sar_post, {\"min\": -25, \"max\": -5}, \"SAR Post-flood\")\n\nm.split_map(\n    left_layer,\n    right_layer,\n    left_label=\"Sentinel-1 Pre-flood\",\n    right_label=\"Sentinel-1 Post_flood\",\n)\nm.add_layer(roi.style(**style), {}, place_name)\nm.center_object(roi, 6)\nm\n</pre> m = geemap.Map() left_layer = geemap.ee_tile_layer(sar_pre, {\"min\": -25, \"max\": -5}, \"SAR Pre-flood\") right_layer = geemap.ee_tile_layer(sar_post, {\"min\": -25, \"max\": -5}, \"SAR Post-flood\")  m.split_map(     left_layer,     right_layer,     left_label=\"Sentinel-1 Pre-flood\",     right_label=\"Sentinel-1 Post_flood\", ) m.add_layer(roi.style(**style), {}, place_name) m.center_object(roi, 6) m Out[28]: In\u00a0[29]: Copied! <pre>threshold = -18\nwater_pre = sar_pre.lt(threshold)\nwater_post = sar_post.lt(threshold)\n</pre> threshold = -18 water_pre = sar_pre.lt(threshold) water_post = sar_post.lt(threshold) <p>Create a split-view map to compare the pre-flood and flood water extent side by side.</p> In\u00a0[30]: Copied! <pre>m = geemap.Map()\nm.add_layer(sar_pre, {\"min\": -25, \"max\": -5}, \"SAR Pre-flood\")\nm.add_layer(sar_post, {\"min\": -25, \"max\": -5}, \"SAR Post-flood\")\n\nleft_layer = geemap.ee_tile_layer(\n    water_pre.selfMask(), {\"palette\": \"blue\"}, \"Water Pre-flood\"\n)\nright_layer = geemap.ee_tile_layer(\n    water_post.selfMask(), {\"palette\": \"red\"}, \"Water Post-flood\"\n)\n\nm.split_map(\n    left_layer,\n    right_layer,\n    left_label=\"Water Pre-flood\",\n    right_label=\"Water Post-flood\",\n)\nm.add_layer(roi.style(**style), {}, place_name)\nm.center_object(roi, 6)\nm\n</pre> m = geemap.Map() m.add_layer(sar_pre, {\"min\": -25, \"max\": -5}, \"SAR Pre-flood\") m.add_layer(sar_post, {\"min\": -25, \"max\": -5}, \"SAR Post-flood\")  left_layer = geemap.ee_tile_layer(     water_pre.selfMask(), {\"palette\": \"blue\"}, \"Water Pre-flood\" ) right_layer = geemap.ee_tile_layer(     water_post.selfMask(), {\"palette\": \"red\"}, \"Water Post-flood\" )  m.split_map(     left_layer,     right_layer,     left_label=\"Water Pre-flood\",     right_label=\"Water Post-flood\", ) m.add_layer(roi.style(**style), {}, place_name) m.center_object(roi, 6) m Out[30]: In\u00a0[31]: Copied! <pre>flood_extent = water_post.subtract(water_pre).gt(0).selfMask()\n</pre> flood_extent = water_post.subtract(water_pre).gt(0).selfMask() <p>The flood extent is the difference between the flood water extent and the pre-flood water extent. In other words, pixels identified as water in the flood period but not in the pre-flood period are considered as flooded pixels, which are shown in cyan.</p> In\u00a0[32]: Copied! <pre>m = geemap.Map()\n\nm.add_layer(sar_pre, {\"min\": -25, \"max\": -5}, \"SAR Pre-flood\")\nm.add_layer(sar_post, {\"min\": -25, \"max\": -5}, \"SAR Post-flood\")\n\nleft_layer = geemap.ee_tile_layer(\n    water_pre.selfMask(), {\"palette\": \"blue\"}, \"Water Pre-flood\"\n)\nright_layer = geemap.ee_tile_layer(\n    water_post.selfMask(), {\"palette\": \"red\"}, \"Water Post-flood\"\n)\n\nm.split_map(\n    left_layer,\n    right_layer,\n    left_label=\"Water Pre-flood\",\n    right_label=\"Water Post-flood\",\n)\n\nm.add_layer(flood_extent, {\"palette\": \"cyan\"}, \"Flood Extent\")\nm.add_layer(roi.style(**style), {}, place_name)\nm.center_object(roi, 6)\nm\n</pre> m = geemap.Map()  m.add_layer(sar_pre, {\"min\": -25, \"max\": -5}, \"SAR Pre-flood\") m.add_layer(sar_post, {\"min\": -25, \"max\": -5}, \"SAR Post-flood\")  left_layer = geemap.ee_tile_layer(     water_pre.selfMask(), {\"palette\": \"blue\"}, \"Water Pre-flood\" ) right_layer = geemap.ee_tile_layer(     water_post.selfMask(), {\"palette\": \"red\"}, \"Water Post-flood\" )  m.split_map(     left_layer,     right_layer,     left_label=\"Water Pre-flood\",     right_label=\"Water Post-flood\", )  m.add_layer(flood_extent, {\"palette\": \"cyan\"}, \"Flood Extent\") m.add_layer(roi.style(**style), {}, place_name) m.center_object(roi, 6) m Out[32]: In\u00a0[33]: Copied! <pre>area_pre_flood = geemap.zonal_stats(\n    water_pre.selfMask(), roi, scale=1000, stat_type=\"SUM\", return_fc=True\n)\ngeemap.ee_to_df(area_pre_flood)\n</pre> area_pre_flood = geemap.zonal_stats(     water_pre.selfMask(), roi, scale=1000, stat_type=\"SUM\", return_fc=True ) geemap.ee_to_df(area_pre_flood) <pre>Computing statistics ...\n</pre> Out[33]: area_1 area_tot_g codigo geocodigo mapid mslink nome perimetro_ sum 0 281748.155 281748.155 43 43 99 223 RIO GRANDE DO SUL 3524.58571 10160.776471 In\u00a0[34]: Copied! <pre>area_2022 = geemap.zonal_stats(\n    water_post.selfMask(), roi, scale=1000, stat_type=\"SUM\", return_fc=True\n)\ngeemap.ee_to_df(area_2022)\n</pre> area_2022 = geemap.zonal_stats(     water_post.selfMask(), roi, scale=1000, stat_type=\"SUM\", return_fc=True ) geemap.ee_to_df(area_2022) <pre>Computing statistics ...\n</pre> Out[34]: area_1 area_tot_g codigo geocodigo mapid mslink nome perimetro_ sum 0 281748.155 281748.155 43 43 99 223 RIO GRANDE DO SUL 3524.58571 13054.921569 In\u00a0[35]: Copied! <pre>flood_area = geemap.zonal_stats(\n    flood_extent.selfMask(), roi, scale=1000, stat_type=\"SUM\", return_fc=True\n)\ngeemap.ee_to_df(flood_area)\n</pre> flood_area = geemap.zonal_stats(     flood_extent.selfMask(), roi, scale=1000, stat_type=\"SUM\", return_fc=True ) geemap.ee_to_df(flood_area) <pre>Computing statistics ...\n</pre> Out[35]: area_1 area_tot_g codigo geocodigo mapid mslink nome perimetro_ sum 0 281748.155 281748.155 43 43 99 223 RIO GRANDE DO SUL 3524.58571 5745.360784"},{"location":"brazil_floods/#visualization-and-analysis-of-brazil-floods-2024","title":"Visualization and Analysis of Brazil Floods 2024\u00b6","text":""},{"location":"brazil_floods/#introduction","title":"Introduction\u00b6","text":"<p>The 2024 Rio Grande do Sul floods are severe floods caused by heavy rains and storms that have hit the Brazilian state of Rio Grande do Sul, and the adjacent Uruguayan cities of Treinta y Tres, Paysand\u00fa, Cerro Largo, and Salto. From 29 April 2024 through to May 2024, it resulted in over 140 fatalities, widespread landslides, and a dam collapse. It is considered the country's worst flooding in over 80 years. See the Wikipedia page for more information about the 2024 Brazil floods.</p>"},{"location":"brazil_floods/#requirements","title":"Requirements\u00b6","text":"<p>To follow this tutorial, you must first sign up for a Google Earth Engine account. Earth Engine is a cloud computing platform with a multi-petabyte catalog of satellite imagery and geospatial datasets. It is free for noncommercial use. To authenticate the Earth Engine Python API, see instructions here.</p> <p>In this tutorial, we will use the geemap Python package to visualize and analyze the Pakistan floods. Geemap enables users to analyze and visualize Earth Engine datasets interactively within a Jupyter-based environment with minimal coding. To learn more about geemap, check out https://geemap.org.</p>"},{"location":"brazil_floods/#installation","title":"Installation\u00b6","text":"<p>Uncomment the following line to install geemap if needed.</p>"},{"location":"brazil_floods/#import-libraries","title":"Import libraries\u00b6","text":"<p>Import the earthengine-api and geemap.</p>"},{"location":"brazil_floods/#download-administrative-boundaries","title":"Download administrative boundaries\u00b6","text":"<p>Download the administrative boundaries of Rio Grande doSul, Brazil from here.</p>"},{"location":"brazil_floods/#create-an-interactive-map","title":"Create an interactive map\u00b6","text":"<p>Specify the center point <code>[lat, lon]</code> and zoom level of the map.</p>"},{"location":"brazil_floods/#create-landsat-composites","title":"Create Landsat composites\u00b6","text":"<p>Create a Landsat 8 composite for the pre-flood period (August 1 to September 30, 2021) using the USGS Landsat 8 Collection 2 Tier 1 Raw Scenes.</p>"},{"location":"brazil_floods/#compare-landsat-composites-side-by-side","title":"Compare Landsat composites side by side\u00b6","text":"<p>Compare the pre-flood and flood composites side by side.</p>"},{"location":"brazil_floods/#compute-normalized-difference-water-index-ndwi","title":"Compute Normalized Difference Water Index (NDWI)\u00b6","text":"<p>The Normalized Difference Water Index (NDWI) is a commonly used index for detecting water bodies. It is calculated as follows:</p> <p>$$NDWI = \\frac{Green - NIR}{Green + NIR}$$</p> <p>where Green is the green band and NIR is the near-infrared band. The NDWI values range from -1 to 1. The NDWI values are usually thresholded to a positive number (e.g., 0.1-0.3) to identify water bodies.</p> <p>Landsat 8 imagery has 11 spectral bands. The Landsat 8 NDWI is calculated using the green (<code>B3</code>) and NIR (<code>B5</code>) bands.</p> <p></p>"},{"location":"brazil_floods/#extract-landsat-water-extent","title":"Extract Landsat water extent\u00b6","text":"<p>To extract the water extent, we need to convert the NDWI images to binary images using a threshold value. The threshold value is usually set to 0.1 to 0.3. The smaller the threshold value, the more water bodies will be detected, which may increase the false positive rate. The larger the threshold value, the fewer water bodies will be detected, which may increase the false negative rate.</p>"},{"location":"brazil_floods/#extract-landsat-flood-extent","title":"Extract Landsat flood extent\u00b6","text":"<p>To extract the flood extent, we need to subtract the pre-flood water extent from the flood water extent. The flood extent is the difference between the flood water extent and the pre-flood water extent. In other words, pixels identified as water in the flood period but not in the pre-flood period are considered as flooded pixels. The <code>selfMask()</code> method is used to mask out the no-data pixels.</p>"},{"location":"brazil_floods/#calculate-landsat-flood-area","title":"Calculate Landsat flood area\u00b6","text":"<p>To calculate the flood area, we can use the <code>geemap.zonal_stats()</code> function. The required input parameters are the flood extent layer and the country boundary layer. The <code>scale</code> parameter can be set to <code>1000</code> to specify the spatial resolution of image to be used for calculating the zonal statistics. The <code>stats_type</code> parameter can be set to <code>SUM</code> to calculate the total area of the flood extent in square kilometers. Set <code>return_fc=True</code> to return the zonal statistics as an <code>ee.FeatureCollection</code> object, which can be converted to a Pandas dataframe.</p>"},{"location":"brazil_floods/#create-sentinel-1-sar-composites","title":"Create Sentinel-1 SAR composites\u00b6","text":"<p>Besides Landsat, we can also use Sentinel-1 Synthetic Aperture Radar (SAR) data to extract flood extent. Radar can collect signals in different polarizations, by controlling the analyzed polarization in both the transmit and receive paths. Signals emitted in vertical (V) and received in horizontal (H) polarization would be indicated by a VH. Alternatively, a signal that was emitted in horizontal (H) and received in horizontal (H) would be indicated by HH, and so on. Examining the signal strength from these different polarizations carries information about the structure of the imaged surface. Rough surface scattering, such as that caused by bare soil or water, is most sensitive to VV scattering. Therefore, VV polarization is often used to detect water bodies.</p> <p>Sentinel-1 operates in four exclusive acquisition modes:</p> <ul> <li>Stripmap (SM)</li> <li>Interferometric Wide swath (IW)</li> <li>Extra-Wide swath (EW)</li> <li>Wave mode (WV)</li> </ul> <p>The Interferometric Wide swath (IW) mode allows combining a large swath width (250 km) with a moderate geometric resolution (5 m by 20 m). The IW mode is the default acquisition mode over land. In this tutorial, we will use Sentinel-1 IW mode data to extract flood extent.</p> <p>The Sentinel-1 SAR data are available from 2014 to present. Let's filter the <code>COPERNICUS/S1_GRD</code> dataset by the date range and location.</p>"},{"location":"brazil_floods/#apply-speckle-filtering","title":"Apply speckle filtering\u00b6","text":"<p>Speckle, appearing in synthetic aperture radar (SAR) images as granular noise, is due to the interference of waves reflected from many elementary scatterers. Speckle in SAR images complicates the image interpretation problem by reducing the effectiveness of image segmentation and classification (Lee et al., 1994). Therefore, speckle filtering is often applied to SAR images to reduce the speckle noise. In this example, we apply a morphological speckle filter to the Sentinel-1 SAR images. The morphological speckle filter is a non-linear filter that uses the median value of a pixel and its neighboring pixels to replace the pixel value. The kernel size is set to 100 meters.</p>"},{"location":"brazil_floods/#compare-sentinel-1-sar-composites-side-by-side","title":"Compare Sentinel-1 SAR composites side by side\u00b6","text":"<p>Create a split-view map to compare the pre-flood and flood SAR composites side by side.</p>"},{"location":"brazil_floods/#extract-sar-water-extent","title":"Extract SAR water extent\u00b6","text":"<p>Water usually appears dark in SAR images because radar waves are reflected differently by different surfaces. Water is a smooth, flat surface that does not reflect radar waves very well, so it appears dark in SAR images. Thresholding SAR imagery is one of the most widely used approaches to delineate water extent for its effectiveness and efficiency (Liang and Liu, 2020). Thresholding methods can be generally divided into two categories: global and local. Global thresholding methods use a single threshold value to segment the entire image. Local thresholding methods use a different threshold value for each pixel. In this example, we use a global thresholding method to extract the water extent. The threshold value is set to -18 dB.</p>"},{"location":"brazil_floods/#extract-sar-flood-extent","title":"Extract SAR flood extent\u00b6","text":"<p>Similar to the Landsat approach, we can subtract the pre-flood water extent from the flood water extent to extract the flood extent.</p>"},{"location":"brazil_floods/#calculate-sar-flood-area","title":"Calculate SAR flood area\u00b6","text":""},{"location":"document/","title":"Document","text":"<p>A markdown document</p>"},{"location":"dongting_lake_floods/","title":"Dongting lake floods","text":"In\u00a0[1]: Copied! <pre># %pip install -U geemap\n</pre> # %pip install -U geemap In\u00a0[2]: Copied! <pre>import ee\nimport geemap.foliumap as geemap\n</pre> import ee import geemap.foliumap as geemap In\u00a0[3]: Copied! <pre>geemap.ee_initialize()\n</pre> geemap.ee_initialize() In\u00a0[4]: Copied! <pre>m = geemap.Map(center=[29.343875, 112.986832], zoom=11)\nm\n</pre> m = geemap.Map(center=[29.343875, 112.986832], zoom=11) m Out[4]: In\u00a0[5]: Copied! <pre>m = geemap.Map()\nm.add_basemap(\"HYBRID\")\ngeom = ee.Geometry.Polygon(\n    [\n        [\n            [112.755432, 29.642708],\n            [112.359924, 28.591757],\n            [113.414612, 28.586933],\n            [113.755188, 29.652256],\n            [112.755432, 29.642708],\n        ]\n    ]\n)\nroi = ee.FeatureCollection(geom)\n\njrc = ee.Image(\"JRC/GSW1_4/GlobalSurfaceWater\").clipToCollection(roi)\nvis_params = {\n    \"bands\": [\"occurrence\"],\n    \"min\": 0.0,\n    \"max\": 100.0,\n    \"palette\": [\"ffffff\", \"ffbbbb\", \"0000ff\"],\n}\nm.add_layer(jrc, vis_params, \"Water Occurrence\")\nm.add_layer(geom, {}, \"ROI\")\nm.center_object(geom)\nm\n</pre> m = geemap.Map() m.add_basemap(\"HYBRID\") geom = ee.Geometry.Polygon(     [         [             [112.755432, 29.642708],             [112.359924, 28.591757],             [113.414612, 28.586933],             [113.755188, 29.652256],             [112.755432, 29.642708],         ]     ] ) roi = ee.FeatureCollection(geom)  jrc = ee.Image(\"JRC/GSW1_4/GlobalSurfaceWater\").clipToCollection(roi) vis_params = {     \"bands\": [\"occurrence\"],     \"min\": 0.0,     \"max\": 100.0,     \"palette\": [\"ffffff\", \"ffbbbb\", \"0000ff\"], } m.add_layer(jrc, vis_params, \"Water Occurrence\") m.add_layer(geom, {}, \"ROI\") m.center_object(geom) m Out[5]: In\u00a0[6]: Copied! <pre>pre_flood_start_date = \"2024-01-01\"\npre_flood_end_date = \"2024-07-04\"\npost_flood_start_date = \"2024-07-05\"\npost_flood_end_date = \"2024-07-17\"\n</pre> pre_flood_start_date = \"2024-01-01\" pre_flood_end_date = \"2024-07-04\" post_flood_start_date = \"2024-07-05\" post_flood_end_date = \"2024-07-17\" In\u00a0[7]: Copied! <pre>pre_flood_col = (\n    ee.ImageCollection(\"NASA/HLS/HLSL30/v002\")\n    .filterBounds(roi)\n    .filterDate(pre_flood_start_date, pre_flood_end_date)\n    .filter(ee.Filter.lt(\"CLOUD_COVERAGE\", 25))\n)\nprint(\n    f\"The number of images in the pre-flood collection: {pre_flood_col.size().getInfo()}\"\n)\n</pre> pre_flood_col = (     ee.ImageCollection(\"NASA/HLS/HLSL30/v002\")     .filterBounds(roi)     .filterDate(pre_flood_start_date, pre_flood_end_date)     .filter(ee.Filter.lt(\"CLOUD_COVERAGE\", 25)) ) print(     f\"The number of images in the pre-flood collection: {pre_flood_col.size().getInfo()}\" ) <pre>The number of images in the pre-flood collection: 20\n</pre> <p>Create a Landsat composite for the post-flood period using the Harmonized Landsat Data.</p> In\u00a0[8]: Copied! <pre>post_flood_col = (\n    ee.ImageCollection(\"NASA/HLS/HLSL30/v002\")\n    .filterBounds(roi)\n    .filterDate(post_flood_start_date, post_flood_end_date)\n    .filter(ee.Filter.lt(\"CLOUD_COVERAGE\", 50))\n)\nprint(\n    f\"The number of images in the post-flood collection: {post_flood_col.size().getInfo()}\"\n)\n</pre> post_flood_col = (     ee.ImageCollection(\"NASA/HLS/HLSL30/v002\")     .filterBounds(roi)     .filterDate(post_flood_start_date, post_flood_end_date)     .filter(ee.Filter.lt(\"CLOUD_COVERAGE\", 50)) ) print(     f\"The number of images in the post-flood collection: {post_flood_col.size().getInfo()}\" ) <pre>The number of images in the post-flood collection: 5\n</pre> <p>Visualize the Landsat composite for the pre-flood and flood periods.</p> In\u00a0[9]: Copied! <pre>m = geemap.Map()\n\npre_flood_image = pre_flood_col.median().clipToCollection(roi)\npost_flood_image = post_flood_col.median().clipToCollection(roi)\n\nvis_params = {\"bands\": [\"B6\", \"B5\", \"B4\"], \"min\": 0, \"max\": 0.4}\nm.add_layer(pre_flood_image, vis_params, \"Landsat Pre-flood\")\nm.add_layer(post_flood_image, vis_params, \"Landsat Post-flood\")\nm.center_object(roi, 9)\nm\n</pre> m = geemap.Map()  pre_flood_image = pre_flood_col.median().clipToCollection(roi) post_flood_image = post_flood_col.median().clipToCollection(roi)  vis_params = {\"bands\": [\"B6\", \"B5\", \"B4\"], \"min\": 0, \"max\": 0.4} m.add_layer(pre_flood_image, vis_params, \"Landsat Pre-flood\") m.add_layer(post_flood_image, vis_params, \"Landsat Post-flood\") m.center_object(roi, 9) m Out[9]: In\u00a0[10]: Copied! <pre>m = geemap.Map()\nleft_layer = geemap.ee_tile_layer(pre_flood_image, vis_params, \"Landsat Pre-flood\")\nright_layer = geemap.ee_tile_layer(post_flood_image, vis_params, \"Landsat Post-flood\")\nm.split_map(\n    left_layer,\n    right_layer,\n    left_label=\"Landsat Pre-flood\",\n    right_label=\"Landsat Post-flood\",\n)\nm.center_object(roi, 9)\nm\n</pre> m = geemap.Map() left_layer = geemap.ee_tile_layer(pre_flood_image, vis_params, \"Landsat Pre-flood\") right_layer = geemap.ee_tile_layer(post_flood_image, vis_params, \"Landsat Post-flood\") m.split_map(     left_layer,     right_layer,     left_label=\"Landsat Pre-flood\",     right_label=\"Landsat Post-flood\", ) m.center_object(roi, 9) m Out[10]: In\u00a0[11]: Copied! <pre>ndwi_pre = pre_flood_image.normalizedDifference([\"B3\", \"B5\"]).rename(\"NDWI\")\nndwi_post = post_flood_image.normalizedDifference([\"B3\", \"B5\"]).rename(\"NDWI\")\n</pre> ndwi_pre = pre_flood_image.normalizedDifference([\"B3\", \"B5\"]).rename(\"NDWI\") ndwi_post = post_flood_image.normalizedDifference([\"B3\", \"B5\"]).rename(\"NDWI\") <p>Compute the NDWI layers for the pre-flood and flood periods side by side.</p> In\u00a0[12]: Copied! <pre>m = geemap.Map()\nndwi_vis = {\"min\": -1, \"max\": 1, \"palette\": \"ndwi\"}\nleft_layer = geemap.ee_tile_layer(ndwi_pre, ndwi_vis, \"NDWI Pre-flood\")\nright_layer = geemap.ee_tile_layer(ndwi_post, ndwi_vis, \"NDWI Post-flood\")\nm.split_map(\n    left_layer, right_layer, left_label=\"NDWI Pre-flood\", right_label=\"NDWI Post-flood\"\n)\nm.center_object(roi, 9)\nm\n</pre> m = geemap.Map() ndwi_vis = {\"min\": -1, \"max\": 1, \"palette\": \"ndwi\"} left_layer = geemap.ee_tile_layer(ndwi_pre, ndwi_vis, \"NDWI Pre-flood\") right_layer = geemap.ee_tile_layer(ndwi_post, ndwi_vis, \"NDWI Post-flood\") m.split_map(     left_layer, right_layer, left_label=\"NDWI Pre-flood\", right_label=\"NDWI Post-flood\" ) m.center_object(roi, 9) m Out[12]: In\u00a0[13]: Copied! <pre>threshold = -0.05\nwater_pre = ndwi_pre.gt(threshold)\nwater_post = ndwi_post.gt(threshold)\n</pre> threshold = -0.05 water_pre = ndwi_pre.gt(threshold) water_post = ndwi_post.gt(threshold) <p>Combine the pre-flood and surface water extent side by side.</p> In\u00a0[14]: Copied! <pre>m = geemap.Map()\n\nm.add_layer(pre_flood_image, vis_params, \"Landsat Pre-flood\", True)\nm.add_layer(post_flood_image, vis_params, \"Landsat Post-flood\", True)\n\nleft_layer = geemap.ee_tile_layer(\n    water_pre.selfMask(), {\"palette\": \"blue\"}, \"Water Pre-flood\"\n)\nright_layer = geemap.ee_tile_layer(\n    water_post.selfMask(), {\"palette\": \"red\"}, \"Water Post-flood\"\n)\n\nm.split_map(\n    left_layer,\n    right_layer,\n    left_label=\"Water Pre-flood\",\n    right_label=\"Water Post-flood\",\n)\nm.center_object(roi, 9)\nm\n</pre> m = geemap.Map()  m.add_layer(pre_flood_image, vis_params, \"Landsat Pre-flood\", True) m.add_layer(post_flood_image, vis_params, \"Landsat Post-flood\", True)  left_layer = geemap.ee_tile_layer(     water_pre.selfMask(), {\"palette\": \"blue\"}, \"Water Pre-flood\" ) right_layer = geemap.ee_tile_layer(     water_post.selfMask(), {\"palette\": \"red\"}, \"Water Post-flood\" )  m.split_map(     left_layer,     right_layer,     left_label=\"Water Pre-flood\",     right_label=\"Water Post-flood\", ) m.center_object(roi, 9) m Out[14]: In\u00a0[15]: Copied! <pre>flood_extent = water_post.subtract(water_pre).gt(0).selfMask()\n</pre> flood_extent = water_post.subtract(water_pre).gt(0).selfMask() <p>Add the flood extent layer to the map.</p> In\u00a0[16]: Copied! <pre>m = geemap.Map()\n\nm.add_layer(pre_flood_image, vis_params, \"Landsat Pre-flood\", True)\nm.add_layer(post_flood_image, vis_params, \"Landsat Post-flood\", True)\n\nleft_layer = geemap.ee_tile_layer(\n    water_pre.selfMask(), {\"palette\": \"blue\"}, \"Water Pre-flood\"\n)\nright_layer = geemap.ee_tile_layer(\n    water_post.selfMask(), {\"palette\": \"red\"}, \"Water Post-flood\"\n)\n\nm.split_map(\n    left_layer,\n    right_layer,\n    left_label=\"Water Pre-flood\",\n    right_label=\"Water Post-flood\",\n)\n\nm.add_layer(flood_extent, {\"palette\": \"cyan\"}, \"Flood Extent\")\nm.center_object(roi, 9)\nm\n</pre> m = geemap.Map()  m.add_layer(pre_flood_image, vis_params, \"Landsat Pre-flood\", True) m.add_layer(post_flood_image, vis_params, \"Landsat Post-flood\", True)  left_layer = geemap.ee_tile_layer(     water_pre.selfMask(), {\"palette\": \"blue\"}, \"Water Pre-flood\" ) right_layer = geemap.ee_tile_layer(     water_post.selfMask(), {\"palette\": \"red\"}, \"Water Post-flood\" )  m.split_map(     left_layer,     right_layer,     left_label=\"Water Pre-flood\",     right_label=\"Water Post-flood\", )  m.add_layer(flood_extent, {\"palette\": \"cyan\"}, \"Flood Extent\") m.center_object(roi, 9) m Out[16]: In\u00a0[17]: Copied! <pre>area_pre_flood = geemap.zonal_stats(\n    water_pre.selfMask(), roi, scale=30, stat_type=\"SUM\", return_fc=True\n)\narea_pre_df = geemap.ee_to_df(area_pre_flood)\narea_pre_df\n</pre> area_pre_flood = geemap.zonal_stats(     water_pre.selfMask(), roi, scale=30, stat_type=\"SUM\", return_fc=True ) area_pre_df = geemap.ee_to_df(area_pre_flood) area_pre_df <pre>Computing statistics ...\n</pre> Out[17]: sum 0 1.357662e+06 In\u00a0[18]: Copied! <pre>print(f\"Pre-flood water area: {round(area_pre_df['sum'].values[0] * 900 / 1e6)} km2\")\n</pre> print(f\"Pre-flood water area: {round(area_pre_df['sum'].values[0] * 900 / 1e6)} km2\") <pre>Pre-flood water area: 1222 km2\n</pre> In\u00a0[19]: Copied! <pre>area_post_flood = geemap.zonal_stats(\n    water_post.selfMask(), roi, scale=30, stat_type=\"SUM\", return_fc=True\n)\narea_post_df = geemap.ee_to_df(area_post_flood)\narea_post_df\n</pre> area_post_flood = geemap.zonal_stats(     water_post.selfMask(), roi, scale=30, stat_type=\"SUM\", return_fc=True ) area_post_df = geemap.ee_to_df(area_post_flood) area_post_df <pre>Computing statistics ...\n</pre> Out[19]: sum 0 3.328183e+06 In\u00a0[20]: Copied! <pre>print(f\"Post-flood water area: {round(area_post_df['sum'].values[0] * 900 / 1e6)} km2\")\n</pre> print(f\"Post-flood water area: {round(area_post_df['sum'].values[0] * 900 / 1e6)} km2\") <pre>Post-flood water area: 2995 km2\n</pre> In\u00a0[21]: Copied! <pre>flood_area = geemap.zonal_stats(\n    flood_extent.selfMask(), roi, scale=30, stat_type=\"SUM\", return_fc=True\n)\nflood_area_df = geemap.ee_to_df(flood_area)\nflood_area_df\n</pre> flood_area = geemap.zonal_stats(     flood_extent.selfMask(), roi, scale=30, stat_type=\"SUM\", return_fc=True ) flood_area_df = geemap.ee_to_df(flood_area) flood_area_df <pre>Computing statistics ...\n</pre> Out[21]: sum 0 2.182365e+06 In\u00a0[22]: Copied! <pre>print(f\"Flooded area: {round(flood_area_df['sum'].values[0] * 900 / 1e6)} km2\")\n</pre> print(f\"Flooded area: {round(flood_area_df['sum'].values[0] * 900 / 1e6)} km2\") <pre>Flooded area: 1964 km2\n</pre> In\u00a0[23]: Copied! <pre>pre_flood_start_date = \"2024-06-01\"\npre_flood_end_date = \"2024-06-30\"\npost_flood_start_date = \"2024-07-05\"\npost_flood_end_date = \"2024-07-17\"\n</pre> pre_flood_start_date = \"2024-06-01\" pre_flood_end_date = \"2024-06-30\" post_flood_start_date = \"2024-07-05\" post_flood_end_date = \"2024-07-17\" <p>Create the Sentinel-1 image collection for the pre-flood period.</p> In\u00a0[24]: Copied! <pre>s1_col_pre = (\n    ee.ImageCollection(\"COPERNICUS/S1_GRD\")\n    .filter(ee.Filter.listContains(\"transmitterReceiverPolarisation\", \"VV\"))\n    .filter(ee.Filter.eq(\"instrumentMode\", \"IW\"))\n    .filterDate(pre_flood_start_date, pre_flood_end_date)\n    .filterBounds(roi)\n    .select(\"VV\")\n)\nprint(\n    f\"The number of images in the pre-flood collection: {s1_col_pre.size().getInfo()}\"\n)\n</pre> s1_col_pre = (     ee.ImageCollection(\"COPERNICUS/S1_GRD\")     .filter(ee.Filter.listContains(\"transmitterReceiverPolarisation\", \"VV\"))     .filter(ee.Filter.eq(\"instrumentMode\", \"IW\"))     .filterDate(pre_flood_start_date, pre_flood_end_date)     .filterBounds(roi)     .select(\"VV\") ) print(     f\"The number of images in the pre-flood collection: {s1_col_pre.size().getInfo()}\" ) <pre>The number of images in the pre-flood collection: 4\n</pre> <p>Create the Sentinel-1 image collection for the post-flood period.</p> In\u00a0[25]: Copied! <pre>s1_col_post = (\n    ee.ImageCollection(\"COPERNICUS/S1_GRD\")\n    .filter(ee.Filter.listContains(\"transmitterReceiverPolarisation\", \"VV\"))\n    .filter(ee.Filter.eq(\"instrumentMode\", \"IW\"))\n    # .filter(ee.Filter.eq('orbitProperties_pass', 'ASCENDING'))\n    .filterDate(post_flood_start_date, post_flood_end_date)\n    .filterBounds(roi)\n    .select(\"VV\")\n)\nprint(\n    f\"The number of images in the post-flood collection: {s1_col_post.size().getInfo()}\"\n)\n</pre> s1_col_post = (     ee.ImageCollection(\"COPERNICUS/S1_GRD\")     .filter(ee.Filter.listContains(\"transmitterReceiverPolarisation\", \"VV\"))     .filter(ee.Filter.eq(\"instrumentMode\", \"IW\"))     # .filter(ee.Filter.eq('orbitProperties_pass', 'ASCENDING'))     .filterDate(post_flood_start_date, post_flood_end_date)     .filterBounds(roi)     .select(\"VV\") ) print(     f\"The number of images in the post-flood collection: {s1_col_post.size().getInfo()}\" ) <pre>The number of images in the post-flood collection: 1\n</pre> <p>Create Sentinel-1 SAR composites for the pre- and post-flood periods.</p> In\u00a0[26]: Copied! <pre>m = geemap.Map()\nm.add_basemap(\"Esri.WorldImagery\")\nsar_pre = s1_col_pre.reduce(ee.Reducer.percentile([20])).clipToCollection(roi)\nsar_post = s1_col_post.reduce(ee.Reducer.percentile([20])).clipToCollection(roi)\nm.add_layer(sar_pre, {\"min\": -25, \"max\": -5}, \"SAR Pre-flood\")\nm.add_layer(sar_post, {\"min\": -25, \"max\": -5}, \"SAR Post-flood\")\nm.center_object(roi, 9)\nm\n</pre> m = geemap.Map() m.add_basemap(\"Esri.WorldImagery\") sar_pre = s1_col_pre.reduce(ee.Reducer.percentile([20])).clipToCollection(roi) sar_post = s1_col_post.reduce(ee.Reducer.percentile([20])).clipToCollection(roi) m.add_layer(sar_pre, {\"min\": -25, \"max\": -5}, \"SAR Pre-flood\") m.add_layer(sar_post, {\"min\": -25, \"max\": -5}, \"SAR Post-flood\") m.center_object(roi, 9) m <pre>Basemap can only be one of the following: OpenStreetMap, ROADMAP, SATELLITE, TERRAIN, HYBRID, FWS NWI Wetlands, FWS NWI Wetlands Raster, NLCD 2021 CONUS Land Cover, NLCD 2019 CONUS Land Cover, NLCD 2016 CONUS Land Cover, NLCD 2013 CONUS Land Cover, NLCD 2011 CONUS Land Cover, NLCD 2008 CONUS Land Cover, NLCD 2006 CONUS Land Cover, NLCD 2004 CONUS Land Cover, NLCD 2001 CONUS Land Cover, USGS NAIP Imagery, USGS NAIP Imagery False Color, USGS NAIP Imagery NDVI, USGS Hydrography, USGS 3DEP Elevation, ESA WorldCover 2020, ESA WorldCover 2020 S2 FCC, ESA WorldCover 2020 S2 TCC, ESA WorldCover 2021, ESA WorldCover 2021 S2 FCC, ESA WorldCover 2021 S2 TCC, BaseMapDE.Color, BaseMapDE.Grey, BasemapAT.basemap, BasemapAT.grau, BasemapAT.highdpi, BasemapAT.orthofoto, BasemapAT.overlay, BasemapAT.surface, BasemapAT.terrain, CartoDB.DarkMatter, CartoDB.DarkMatterNoLabels, CartoDB.DarkMatterOnlyLabels, CartoDB.Positron, CartoDB.PositronNoLabels, CartoDB.PositronOnlyLabels, CartoDB.Voyager, CartoDB.VoyagerLabelsUnder, CartoDB.VoyagerNoLabels, CartoDB.VoyagerOnlyLabels, CyclOSM, Esri.AntarcticBasemap, Esri.AntarcticImagery, Esri.ArcticImagery, Esri.ArcticOceanBase, Esri.ArcticOceanReference, Esri.DeLorme, Esri.NatGeoWorldMap, Esri.OceanBasemap, Esri.WorldGrayCanvas, Esri.WorldPhysical, Esri.WorldShadedRelief, Esri.WorldTerrain, FreeMapSK, Gaode.Normal, Gaode.Satellite, HikeBike.HikeBike, HikeBike.HillShading, JusticeMap.americanIndian, JusticeMap.asian, JusticeMap.black, JusticeMap.hispanic, JusticeMap.income, JusticeMap.multi, JusticeMap.nonWhite, JusticeMap.plurality, JusticeMap.white, MtbMap, NASAGIBS.ASTER_GDEM_Greyscale_Shaded_Relief, NASAGIBS.BlueMarble3031, NASAGIBS.BlueMarble3413, NASAGIBS.ModisAquaBands721CR, NASAGIBS.ModisAquaTrueColorCR, NASAGIBS.ModisTerraAOD, NASAGIBS.ModisTerraBands367CR, NASAGIBS.ModisTerraBands721CR, NASAGIBS.ModisTerraChlorophyll, NASAGIBS.ModisTerraLSTDay, NASAGIBS.ModisTerraSnowCover, NASAGIBS.ModisTerraTrueColorCR, NASAGIBS.ViirsEarthAtNight2012, NASAGIBS.ViirsTrueColorCR, OPNVKarte, OneMapSG.Default, OneMapSG.Grey, OneMapSG.LandLot, OneMapSG.Night, OneMapSG.Original, OpenAIP, OpenFireMap, OpenRailwayMap, OpenSeaMap, OpenSnowMap.pistes, OpenStreetMap.BZH, OpenStreetMap.BlackAndWhite, OpenStreetMap.CH, OpenStreetMap.DE, OpenStreetMap.HOT, OpenStreetMap.Mapnik, OpenTopoMap, SafeCast, Stadia.AlidadeSmooth, Stadia.AlidadeSmoothDark, Stadia.OSMBright, Stadia.Outdoors, Stadia.StamenTerrain, Stadia.StamenTerrainBackground, Stadia.StamenTerrainLabels, Stadia.StamenTerrainLines, Stadia.StamenToner, Stadia.StamenTonerBackground, Stadia.StamenTonerLabels, Stadia.StamenTonerLines, Stadia.StamenTonerLite, Stadia.StamenWatercolor, Strava.All, Strava.Ride, Strava.Run, Strava.Water, Strava.Winter, SwissFederalGeoportal.JourneyThroughTime, SwissFederalGeoportal.NationalMapColor, SwissFederalGeoportal.NationalMapGrey, SwissFederalGeoportal.SWISSIMAGE, TopPlusOpen.Color, TopPlusOpen.Grey, USGS.USImagery, USGS.USImageryTopo, USGS.USTopo, WaymarkedTrails.cycling, WaymarkedTrails.hiking, WaymarkedTrails.mtb, WaymarkedTrails.riding, WaymarkedTrails.skating, WaymarkedTrails.slopes, nlmaps.grijs, nlmaps.luchtfoto, nlmaps.pastel, nlmaps.standaard, nlmaps.water\n</pre> Out[26]: In\u00a0[27]: Copied! <pre>s1_col_pre = s1_col_pre.map(lambda img: img.focal_median(100, \"circle\", \"meters\"))\ns1_col_post = s1_col_post.map(lambda img: img.focal_median(100, \"circle\", \"meters\"))\n</pre> s1_col_pre = s1_col_pre.map(lambda img: img.focal_median(100, \"circle\", \"meters\")) s1_col_post = s1_col_post.map(lambda img: img.focal_median(100, \"circle\", \"meters\")) In\u00a0[28]: Copied! <pre>m = geemap.Map()\nm.add_basemap(\"Esri.WorldImagery\")\nsar_pre = s1_col_pre.reduce(ee.Reducer.percentile([20])).clipToCollection(roi)\nsar_post = s1_col_post.reduce(ee.Reducer.percentile([20])).clipToCollection(roi)\nm.add_layer(sar_pre, {\"min\": -25, \"max\": -5}, \"SAR Pre-flood\")\nm.add_layer(sar_post, {\"min\": -25, \"max\": -5}, \"SAR Post-flood\")\nm.center_object(roi, 9)\nm\n</pre> m = geemap.Map() m.add_basemap(\"Esri.WorldImagery\") sar_pre = s1_col_pre.reduce(ee.Reducer.percentile([20])).clipToCollection(roi) sar_post = s1_col_post.reduce(ee.Reducer.percentile([20])).clipToCollection(roi) m.add_layer(sar_pre, {\"min\": -25, \"max\": -5}, \"SAR Pre-flood\") m.add_layer(sar_post, {\"min\": -25, \"max\": -5}, \"SAR Post-flood\") m.center_object(roi, 9) m <pre>Basemap can only be one of the following: OpenStreetMap, ROADMAP, SATELLITE, TERRAIN, HYBRID, FWS NWI Wetlands, FWS NWI Wetlands Raster, NLCD 2021 CONUS Land Cover, NLCD 2019 CONUS Land Cover, NLCD 2016 CONUS Land Cover, NLCD 2013 CONUS Land Cover, NLCD 2011 CONUS Land Cover, NLCD 2008 CONUS Land Cover, NLCD 2006 CONUS Land Cover, NLCD 2004 CONUS Land Cover, NLCD 2001 CONUS Land Cover, USGS NAIP Imagery, USGS NAIP Imagery False Color, USGS NAIP Imagery NDVI, USGS Hydrography, USGS 3DEP Elevation, ESA WorldCover 2020, ESA WorldCover 2020 S2 FCC, ESA WorldCover 2020 S2 TCC, ESA WorldCover 2021, ESA WorldCover 2021 S2 FCC, ESA WorldCover 2021 S2 TCC, BaseMapDE.Color, BaseMapDE.Grey, BasemapAT.basemap, BasemapAT.grau, BasemapAT.highdpi, BasemapAT.orthofoto, BasemapAT.overlay, BasemapAT.surface, BasemapAT.terrain, CartoDB.DarkMatter, CartoDB.DarkMatterNoLabels, CartoDB.DarkMatterOnlyLabels, CartoDB.Positron, CartoDB.PositronNoLabels, CartoDB.PositronOnlyLabels, CartoDB.Voyager, CartoDB.VoyagerLabelsUnder, CartoDB.VoyagerNoLabels, CartoDB.VoyagerOnlyLabels, CyclOSM, Esri.AntarcticBasemap, Esri.AntarcticImagery, Esri.ArcticImagery, Esri.ArcticOceanBase, Esri.ArcticOceanReference, Esri.DeLorme, Esri.NatGeoWorldMap, Esri.OceanBasemap, Esri.WorldGrayCanvas, Esri.WorldPhysical, Esri.WorldShadedRelief, Esri.WorldTerrain, FreeMapSK, Gaode.Normal, Gaode.Satellite, HikeBike.HikeBike, HikeBike.HillShading, JusticeMap.americanIndian, JusticeMap.asian, JusticeMap.black, JusticeMap.hispanic, JusticeMap.income, JusticeMap.multi, JusticeMap.nonWhite, JusticeMap.plurality, JusticeMap.white, MtbMap, NASAGIBS.ASTER_GDEM_Greyscale_Shaded_Relief, NASAGIBS.BlueMarble3031, NASAGIBS.BlueMarble3413, NASAGIBS.ModisAquaBands721CR, NASAGIBS.ModisAquaTrueColorCR, NASAGIBS.ModisTerraAOD, NASAGIBS.ModisTerraBands367CR, NASAGIBS.ModisTerraBands721CR, NASAGIBS.ModisTerraChlorophyll, NASAGIBS.ModisTerraLSTDay, NASAGIBS.ModisTerraSnowCover, NASAGIBS.ModisTerraTrueColorCR, NASAGIBS.ViirsEarthAtNight2012, NASAGIBS.ViirsTrueColorCR, OPNVKarte, OneMapSG.Default, OneMapSG.Grey, OneMapSG.LandLot, OneMapSG.Night, OneMapSG.Original, OpenAIP, OpenFireMap, OpenRailwayMap, OpenSeaMap, OpenSnowMap.pistes, OpenStreetMap.BZH, OpenStreetMap.BlackAndWhite, OpenStreetMap.CH, OpenStreetMap.DE, OpenStreetMap.HOT, OpenStreetMap.Mapnik, OpenTopoMap, SafeCast, Stadia.AlidadeSmooth, Stadia.AlidadeSmoothDark, Stadia.OSMBright, Stadia.Outdoors, Stadia.StamenTerrain, Stadia.StamenTerrainBackground, Stadia.StamenTerrainLabels, Stadia.StamenTerrainLines, Stadia.StamenToner, Stadia.StamenTonerBackground, Stadia.StamenTonerLabels, Stadia.StamenTonerLines, Stadia.StamenTonerLite, Stadia.StamenWatercolor, Strava.All, Strava.Ride, Strava.Run, Strava.Water, Strava.Winter, SwissFederalGeoportal.JourneyThroughTime, SwissFederalGeoportal.NationalMapColor, SwissFederalGeoportal.NationalMapGrey, SwissFederalGeoportal.SWISSIMAGE, TopPlusOpen.Color, TopPlusOpen.Grey, USGS.USImagery, USGS.USImageryTopo, USGS.USTopo, WaymarkedTrails.cycling, WaymarkedTrails.hiking, WaymarkedTrails.mtb, WaymarkedTrails.riding, WaymarkedTrails.skating, WaymarkedTrails.slopes, nlmaps.grijs, nlmaps.luchtfoto, nlmaps.pastel, nlmaps.standaard, nlmaps.water\n</pre> Out[28]: In\u00a0[29]: Copied! <pre>m = geemap.Map()\nleft_layer = geemap.ee_tile_layer(sar_pre, {\"min\": -25, \"max\": -5}, \"SAR Pre-flood\")\nright_layer = geemap.ee_tile_layer(sar_post, {\"min\": -25, \"max\": -5}, \"SAR Post-flood\")\n\nm.split_map(\n    left_layer,\n    right_layer,\n    left_label=\"Sentinel-1 Pre-flood\",\n    right_label=\"Sentinel-1 Post_flood\",\n)\nm.center_object(roi, 9)\nm\n</pre> m = geemap.Map() left_layer = geemap.ee_tile_layer(sar_pre, {\"min\": -25, \"max\": -5}, \"SAR Pre-flood\") right_layer = geemap.ee_tile_layer(sar_post, {\"min\": -25, \"max\": -5}, \"SAR Post-flood\")  m.split_map(     left_layer,     right_layer,     left_label=\"Sentinel-1 Pre-flood\",     right_label=\"Sentinel-1 Post_flood\", ) m.center_object(roi, 9) m Out[29]: In\u00a0[30]: Copied! <pre>threshold = -16\nwater_pre = sar_pre.lt(threshold)\nwater_post = sar_post.lt(threshold)\n</pre> threshold = -16 water_pre = sar_pre.lt(threshold) water_post = sar_post.lt(threshold) <p>Create a split-view map to compare the pre-flood and flood water extent side by side.</p> In\u00a0[31]: Copied! <pre>m = geemap.Map()\nm.add_layer(sar_pre, {\"min\": -25, \"max\": -5}, \"SAR Pre-flood\")\nm.add_layer(sar_post, {\"min\": -25, \"max\": -5}, \"SAR Post-flood\")\n\nleft_layer = geemap.ee_tile_layer(\n    water_pre.selfMask(), {\"palette\": \"blue\"}, \"Water Pre-flood\"\n)\nright_layer = geemap.ee_tile_layer(\n    water_post.selfMask(), {\"palette\": \"red\"}, \"Water Post-flood\"\n)\n\nm.split_map(\n    left_layer,\n    right_layer,\n    left_label=\"Water Pre-flood\",\n    right_label=\"Water Post-flood\",\n)\nm.center_object(roi, 9)\nm\n</pre> m = geemap.Map() m.add_layer(sar_pre, {\"min\": -25, \"max\": -5}, \"SAR Pre-flood\") m.add_layer(sar_post, {\"min\": -25, \"max\": -5}, \"SAR Post-flood\")  left_layer = geemap.ee_tile_layer(     water_pre.selfMask(), {\"palette\": \"blue\"}, \"Water Pre-flood\" ) right_layer = geemap.ee_tile_layer(     water_post.selfMask(), {\"palette\": \"red\"}, \"Water Post-flood\" )  m.split_map(     left_layer,     right_layer,     left_label=\"Water Pre-flood\",     right_label=\"Water Post-flood\", ) m.center_object(roi, 9) m Out[31]: In\u00a0[32]: Copied! <pre>flood_extent = water_post.subtract(water_pre).gt(0).selfMask()\n</pre> flood_extent = water_post.subtract(water_pre).gt(0).selfMask() <p>The flood extent is the difference between the flood water extent and the pre-flood water extent. In other words, pixels identified as water in the flood period but not in the pre-flood period are considered as flooded pixels, which are shown in cyan.</p> In\u00a0[33]: Copied! <pre>m = geemap.Map()\n\nm.add_layer(sar_pre, {\"min\": -25, \"max\": -5}, \"SAR Pre-flood\")\nm.add_layer(sar_post, {\"min\": -25, \"max\": -5}, \"SAR Post-flood\")\n\nleft_layer = geemap.ee_tile_layer(\n    water_pre.selfMask(), {\"palette\": \"blue\"}, \"Water Pre-flood\"\n)\nright_layer = geemap.ee_tile_layer(\n    water_post.selfMask(), {\"palette\": \"red\"}, \"Water Post-flood\"\n)\n\nm.split_map(\n    left_layer,\n    right_layer,\n    left_label=\"Water Pre-flood\",\n    right_label=\"Water Post-flood\",\n)\n\nm.add_layer(flood_extent, {\"palette\": \"cyan\"}, \"Flood Extent\")\nm.center_object(roi, 9)\nm\n</pre> m = geemap.Map()  m.add_layer(sar_pre, {\"min\": -25, \"max\": -5}, \"SAR Pre-flood\") m.add_layer(sar_post, {\"min\": -25, \"max\": -5}, \"SAR Post-flood\")  left_layer = geemap.ee_tile_layer(     water_pre.selfMask(), {\"palette\": \"blue\"}, \"Water Pre-flood\" ) right_layer = geemap.ee_tile_layer(     water_post.selfMask(), {\"palette\": \"red\"}, \"Water Post-flood\" )  m.split_map(     left_layer,     right_layer,     left_label=\"Water Pre-flood\",     right_label=\"Water Post-flood\", )  m.add_layer(flood_extent, {\"palette\": \"cyan\"}, \"Flood Extent\") m.center_object(roi, 9) m Out[33]: In\u00a0[34]: Copied! <pre>area_pre_flood = geemap.zonal_stats(\n    water_pre.selfMask(), roi, scale=30, stat_type=\"SUM\", return_fc=True\n)\narea_pre_df = geemap.ee_to_df(area_pre_flood)\narea_pre_df\n</pre> area_pre_flood = geemap.zonal_stats(     water_pre.selfMask(), roi, scale=30, stat_type=\"SUM\", return_fc=True ) area_pre_df = geemap.ee_to_df(area_pre_flood) area_pre_df <pre>Computing statistics ...\n</pre> Out[34]: sum 0 2.333509e+06 In\u00a0[35]: Copied! <pre>print(f\"Pre-flood water area: {round(area_pre_df['sum'].values[0] * 900 / 1e6)} km2\")\n</pre> print(f\"Pre-flood water area: {round(area_pre_df['sum'].values[0] * 900 / 1e6)} km2\") <pre>Pre-flood water area: 2100 km2\n</pre> In\u00a0[36]: Copied! <pre>area_post_flood = geemap.zonal_stats(\n    water_post.selfMask(), roi, scale=30, stat_type=\"SUM\", return_fc=True\n)\narea_post_df = geemap.ee_to_df(area_post_flood)\narea_post_df\n</pre> area_post_flood = geemap.zonal_stats(     water_post.selfMask(), roi, scale=30, stat_type=\"SUM\", return_fc=True ) area_post_df = geemap.ee_to_df(area_post_flood) area_post_df <pre>Computing statistics ...\n</pre> Out[36]: sum 0 2.454894e+06 In\u00a0[37]: Copied! <pre>print(f\"Post-flood water area: {round(area_post_df['sum'].values[0] * 900 / 1e6)} km2\")\n</pre> print(f\"Post-flood water area: {round(area_post_df['sum'].values[0] * 900 / 1e6)} km2\") <pre>Post-flood water area: 2209 km2\n</pre> In\u00a0[38]: Copied! <pre>flood_area = geemap.zonal_stats(\n    flood_extent.selfMask(), roi, scale=30, stat_type=\"SUM\", return_fc=True\n)\nflood_area_df = geemap.ee_to_df(flood_area)\nflood_area_df\n</pre> flood_area = geemap.zonal_stats(     flood_extent.selfMask(), roi, scale=30, stat_type=\"SUM\", return_fc=True ) flood_area_df = geemap.ee_to_df(flood_area) flood_area_df <pre>Computing statistics ...\n</pre> Out[38]: sum 0 550634.537255 In\u00a0[39]: Copied! <pre>print(f\"Flooded area: {round(flood_area_df['sum'].values[0] * 900 / 1e6)} km2\")\n</pre> print(f\"Flooded area: {round(flood_area_df['sum'].values[0] * 900 / 1e6)} km2\") <pre>Flooded area: 496 km2\n</pre>"},{"location":"dongting_lake_floods/#visualization-and-analysis-of-dongting-lake-floods-2024","title":"Visualization and Analysis of Dongting Lake Floods 2024\u00b6","text":""},{"location":"dongting_lake_floods/#introduction","title":"Introduction\u00b6","text":"<p>Dongting Lake, China's second-largest freshwater lake, burst its embankment on July 5, 2024, flooding more than 47 sq km (18 square miles). The floods have affected more than 364,000 people, inundated farmland, damaged over 2,600 sections of roads and bridges and caused multiple landslides in Pingjiang. For more information, please refer to the South China Morning Post.</p> <p></p>"},{"location":"dongting_lake_floods/#requirements","title":"Requirements\u00b6","text":"<p>To follow this tutorial, you must first sign up for a Google Earth Engine account. Earth Engine is a cloud computing platform with a multi-petabyte catalog of satellite imagery and geospatial datasets. It is free for noncommercial use. To authenticate the Earth Engine Python API, see instructions here.</p> <p>In this tutorial, we will use the geemap Python package to visualize and analyze the Dongting Lake floods. Geemap enables users to analyze and visualize Earth Engine datasets interactively within a Jupyter-based environment with minimal coding. To learn more about geemap, check out https://geemap.org.</p>"},{"location":"dongting_lake_floods/#installation","title":"Installation\u00b6","text":"<p>Uncomment the following line to install geemap if needed.</p>"},{"location":"dongting_lake_floods/#import-libraries","title":"Import libraries\u00b6","text":"<p>Import the earthengine-api and geemap.</p>"},{"location":"dongting_lake_floods/#create-an-interactive-map","title":"Create an interactive map\u00b6","text":""},{"location":"dongting_lake_floods/#specify-roi-and-time-range","title":"Specify ROI and time range\u00b6","text":"<p>In the tutorial, we will focus on the Dongting Lake in China, but the code can be easily modified to visualize and analyze floods in other countries or regions. Modify the <code>geom</code> variable to specify the place of interest and set the date range for the flood event. In order to extract the flood extent, we also need to specify the date range for the pre-flood period.</p>"},{"location":"dongting_lake_floods/#create-landsat-composites","title":"Create Landsat composites\u00b6","text":"<p>Create a Landsat composite for the pre-flood period using the Harmonized Landsat Data.</p>"},{"location":"dongting_lake_floods/#compare-landsat-composites-side-by-side","title":"Compare Landsat composites side by side\u00b6","text":"<p>Compare the pre-flood and flood composites side by side.</p>"},{"location":"dongting_lake_floods/#compute-normalized-difference-water-index-ndwi","title":"Compute Normalized Difference Water Index (NDWI)\u00b6","text":"<p>The Normalized Difference Water Index (NDWI) is a commonly used index for detecting water bodies. It is calculated as follows:</p> <p>$$NDWI = \\frac{Green - NIR}{Green + NIR}$$</p> <p>where Green is the green band and NIR is the near-infrared band. The NDWI values range from -1 to 1. The NDWI values are usually thresholded to a positive number (e.g., 0.1-0.3) to identify water bodies.</p> <p>Landsat 8 imagery has 11 spectral bands. The Landsat 8 NDWI is calculated using the green (<code>B3</code>) and NIR (<code>B5</code>) bands.</p> <p></p>"},{"location":"dongting_lake_floods/#extract-landsat-water-extent","title":"Extract Landsat water extent\u00b6","text":"<p>To extract the water extent, we need to convert the NDWI images to binary images using a threshold value. The threshold value is usually set to 0 to 0.3. The smaller the threshold value, the more water bodies will be detected, which may increase the false positive rate. The larger the threshold value, the fewer water bodies will be detected, which may increase the false negative rate.</p>"},{"location":"dongting_lake_floods/#extract-landsat-flood-extent","title":"Extract Landsat flood extent\u00b6","text":"<p>To extract the flood extent, we need to subtract the pre-flood water extent from the flood water extent. The flood extent is the difference between the flood water extent and the pre-flood water extent. In other words, pixels identified as water in the flood period but not in the pre-flood period are considered as flooded pixels. The <code>selfMask()</code> method is used to mask out the no-data pixels.</p>"},{"location":"dongting_lake_floods/#calculate-landsat-flood-area","title":"Calculate Landsat flood area\u00b6","text":"<p>To calculate the flood area, we can use the <code>geemap.zonal_stats()</code> function. The required input parameters are the flood extent layer and the country boundary layer. The <code>scale</code> parameter can be set to <code>30</code> to specify the spatial resolution of image to be used for calculating the zonal statistics. The <code>stats_type</code> parameter can be set to <code>SUM</code> to calculate the total area of the flood extent in square meters. Set <code>return_fc=True</code> to return the zonal statistics as an <code>ee.FeatureCollection</code> object, which can be converted to a Pandas dataframe.</p>"},{"location":"dongting_lake_floods/#create-sentinel-1-sar-composites","title":"Create Sentinel-1 SAR composites\u00b6","text":"<p>Besides Landsat, we can also use Sentinel-1 Synthetic Aperture Radar (SAR) data to extract flood extent. Radar can collect signals in different polarizations, by controlling the analyzed polarization in both the transmit and receive paths. Signals emitted in vertical (V) and received in horizontal (H) polarization would be indicated by a VH. Alternatively, a signal that was emitted in horizontal (H) and received in horizontal (H) would be indicated by HH, and so on. Examining the signal strength from these different polarizations carries information about the structure of the imaged surface. Rough surface scattering, such as that caused by bare soil or water, is most sensitive to VV scattering. Therefore, VV polarization is often used to detect water bodies.</p> <p>Sentinel-1 operates in four exclusive acquisition modes:</p> <ul> <li>Stripmap (SM)</li> <li>Interferometric Wide swath (IW)</li> <li>Extra-Wide swath (EW)</li> <li>Wave mode (WV)</li> </ul> <p>The Interferometric Wide swath (IW) mode allows combining a large swath width (250 km) with a moderate geometric resolution (5 m by 20 m). The IW mode is the default acquisition mode over land. In this tutorial, we will use Sentinel-1 IW mode data to extract flood extent.</p> <p>The Sentinel-1 SAR data are available from 2014 to present. Let's filter the <code>COPERNICUS/S1_GRD</code> dataset by the date range and location.</p>"},{"location":"dongting_lake_floods/#apply-speckle-filtering","title":"Apply speckle filtering\u00b6","text":"<p>Speckle, appearing in synthetic aperture radar (SAR) images as granular noise, is due to the interference of waves reflected from many elementary scatterers. Speckle in SAR images complicates the image interpretation problem by reducing the effectiveness of image segmentation and classification (Lee et al., 1994). Therefore, speckle filtering is often applied to SAR images to reduce the speckle noise. In this example, we apply a morphological speckle filter to the Sentinel-1 SAR images. The morphological speckle filter is a non-linear filter that uses the median value of a pixel and its neighboring pixels to replace the pixel value. The kernel size is set to 100 meters.</p>"},{"location":"dongting_lake_floods/#compare-sentinel-1-sar-composites-side-by-side","title":"Compare Sentinel-1 SAR composites side by side\u00b6","text":"<p>Create a split-view map to compare the pre-flood and flood SAR composites side by side.</p>"},{"location":"dongting_lake_floods/#extract-sar-water-extent","title":"Extract SAR water extent\u00b6","text":"<p>Water usually appears dark in SAR images because radar waves are reflected differently by different surfaces. Water is a smooth, flat surface that does not reflect radar waves very well, so it appears dark in SAR images. Thresholding SAR imagery is one of the most widely used approaches to delineate water extent for its effectiveness and efficiency (Liang and Liu, 2020). Thresholding methods can be generally divided into two categories: global and local. Global thresholding methods use a single threshold value to segment the entire image. Local thresholding methods use a different threshold value for each pixel. In this example, we use a global thresholding method to extract the water extent. The threshold value is set to -16 dB.</p>"},{"location":"dongting_lake_floods/#extract-sar-flood-extent","title":"Extract SAR flood extent\u00b6","text":"<p>Similar to the Landsat approach, we can subtract the pre-flood water extent from the flood water extent to extract the flood extent.</p>"},{"location":"dongting_lake_floods/#calculate-sar-flood-area","title":"Calculate SAR flood area\u00b6","text":""},{"location":"goes_timelapse/","title":"Goes timelapse","text":"<p>Create satellite timelapse with geemap and GOES imagery</p> In\u00a0[\u00a0]: Copied! <pre># !pip install geemap\n</pre> # !pip install geemap In\u00a0[1]: Copied! <pre>import ee\nimport geemap\n</pre> import ee import geemap In\u00a0[\u00a0]: Copied! <pre>geemap.ee_initialize()\n</pre> geemap.ee_initialize() In\u00a0[\u00a0]: Copied! <pre>Map = geemap.Map()\nMap\n</pre> Map = geemap.Map() Map In\u00a0[\u00a0]: Copied! <pre>start_date = \"2022-12-24T16:00:00\"\nend_date = \"2022-12-25T00:00:00\"\ndata = \"GOES-17\"\nscan = \"full_disk\"\n</pre> start_date = \"2022-12-24T16:00:00\" end_date = \"2022-12-25T00:00:00\" data = \"GOES-17\" scan = \"full_disk\" In\u00a0[\u00a0]: Copied! <pre>roi = ee.Geometry.BBox(-127.6144, 25.0060, -64.6848, 61.4076)\n</pre> roi = ee.Geometry.BBox(-127.6144, 25.0060, -64.6848, 61.4076) In\u00a0[\u00a0]: Copied! <pre>roi = Map.user_roi\n</pre> roi = Map.user_roi In\u00a0[\u00a0]: Copied! <pre>Map.user_roi_coords()\n</pre> Map.user_roi_coords() In\u00a0[\u00a0]: Copied! <pre>timelapse = geemap.goes_timelapse(\n    roi,\n    \"goes.gif\",\n    start_date,\n    end_date,\n    data,\n    scan,\n    framesPerSecond=5,\n    crs=\"EPSG:3857\",\n    overlay_data=\"us_states\",\n)\ngeemap.show_image(timelapse)\n</pre> timelapse = geemap.goes_timelapse(     roi,     \"goes.gif\",     start_date,     end_date,     data,     scan,     framesPerSecond=5,     crs=\"EPSG:3857\",     overlay_data=\"us_states\", ) geemap.show_image(timelapse) <p></p> In\u00a0[\u00a0]: Copied! <pre>start_date = \"2022-12-25T16:00:00\"\nend_date = \"2022-12-26T00:00:00\"\nroi = ee.Geometry.BBox(-168.7747, 14.4932, -64.1849, 67.4383)\n</pre> start_date = \"2022-12-25T16:00:00\" end_date = \"2022-12-26T00:00:00\" roi = ee.Geometry.BBox(-168.7747, 14.4932, -64.1849, 67.4383) In\u00a0[\u00a0]: Copied! <pre>timelapse = geemap.goes_timelapse(\n    Map.user_roi,\n    \"goes2.gif\",\n    start_date,\n    end_date,\n    data,\n    scan,\n    framesPerSecond=5,\n    crs=\"EPSG:3857\",\n    overlay_data=\"us_states\",\n)\ngeemap.show_image(timelapse)\n</pre> timelapse = geemap.goes_timelapse(     Map.user_roi,     \"goes2.gif\",     start_date,     end_date,     data,     scan,     framesPerSecond=5,     crs=\"EPSG:3857\",     overlay_data=\"us_states\", ) geemap.show_image(timelapse) <p></p>"},{"location":"morocco_earthquake/","title":"Morocco earthquake","text":"<p>Visualizing Maxar Open Data for the 2023 Morocco Earthquake with Leafmap</p> <p>The Maxar Open Data Program provides pre- and post-event high-resolution satellite imagery in support of emergency planning, risk assessment, monitoring of staging areas and emergency response, damage assessment, and recovery. Check out the links below for more information.</p> <ul> <li>Maxar Open Data Program</li> <li>Maxar Open Data on AWS</li> <li>Maxar Open Data on STAC Index</li> <li>Maxar Open Data on STAC Browser</li> </ul> <p>The Maxar Open Data STAC catalog URL is: https://maxar-opendata.s3.amazonaws.com/events/catalog.json</p> In\u00a0[1]: Copied! <pre># !pip install -U leafmap geopandas cogeo-mosaic\n</pre> # !pip install -U leafmap geopandas cogeo-mosaic In\u00a0[2]: Copied! <pre>import leafmap.foliumap as leafmap\n</pre> import leafmap.foliumap as leafmap <p>Retrieve all collections from the Maxar Open Data STAC catalog. Each collection represents a single event.</p> In\u00a0[3]: Copied! <pre>leafmap.maxar_collections()\n</pre> leafmap.maxar_collections() Out[3]: <pre>['BayofBengal-Cyclone-Mocha-May-23',\n 'Emilia-Romagna-Italy-flooding-may23',\n 'Gambia-flooding-8-11-2022',\n 'Hurricane-Fiona-9-19-2022',\n 'Hurricane-Ian-9-26-2022',\n 'Hurricane-Idalia-Florida-Aug23',\n 'Indonesia-Earthquake22',\n 'Kahramanmaras-turkey-earthquake-23',\n 'Kalehe-DRC-Flooding-5-8-23',\n 'Libya-Floods-Sept-2023',\n 'Marshall-Fire-21-Update',\n 'Maui-Hawaii-fires-Aug-23',\n 'McDougallCreekWildfire-BC-Canada-Aug-23',\n 'Morocco-Earthquake-Sept-2023',\n 'NWT-Canada-Aug-23',\n 'New-Zealand-Flooding22',\n 'New-Zealand-Flooding23',\n 'Sudan-flooding-8-22-2022',\n 'afghanistan-earthquake22',\n 'cyclone-emnati22',\n 'ghana-explosion22',\n 'kentucky-flooding-7-29-2022',\n 'pakistan-flooding22',\n 'shovi-georgia-landslide-8Aug23',\n 'southafrica-flooding22',\n 'tonga-volcano21',\n 'volcano-indonesia21',\n 'yellowstone-flooding22']</pre> <p>Retrieve all collections for a specific event:</p> In\u00a0[4]: Copied! <pre>collections = leafmap.maxar_child_collections(\"Morocco-Earthquake-Sept-2023\")\nprint(f\"The number of collections: {len(collections)}\")\n</pre> collections = leafmap.maxar_child_collections(\"Morocco-Earthquake-Sept-2023\") print(f\"The number of collections: {len(collections)}\") <pre>The number of collections: 244\n</pre> In\u00a0[\u00a0]: Copied! <pre>collections.sort()\ncollections\n</pre> collections.sort() collections <p>Retrieve all items (tiles) for a specific collection and generate the footprints:</p> In\u00a0[6]: Copied! <pre>gdf = leafmap.maxar_items(\n    collection_id=\"Morocco-Earthquake-Sept-2023\",\n    child_id=\"10300100ECC53700\",\n    return_gdf=True,\n    assets=[\"visual\"],\n)\ngdf.head()\n</pre> gdf = leafmap.maxar_items(     collection_id=\"Morocco-Earthquake-Sept-2023\",     child_id=\"10300100ECC53700\",     return_gdf=True,     assets=[\"visual\"], ) gdf.head() Out[6]: geometry datetime platform gsd ard_metadata_version catalog_id utm_zone quadkey view:off_nadir view:azimuth ... view:sun_azimuth view:sun_elevation proj:epsg proj:geometry grid:code proj:bbox tile:data_area tile:clouds_area tile:clouds_percent visual 0 POLYGON ((-8.99837 30.61125, -8.99837 30.59612... 2023-09-10T11:46:24Z WV02 0.83 0.0.1 10300100ECC53700 29 031313133131 41.5 234.2 ... 154.6 62.3 32629 {'type': 'Polygon', 'coordinates': [[[500155.9... MXRA-Z29-031313133131 497536.92626953125,3384843.75,500156.25,338652... 3.2 0.0 0 https://maxar-opendata.s3.amazonaws.com/events... 1 POLYGON ((-9.02553 30.59894, -8.99837 30.59894... 2023-09-10T11:46:24Z WV02 0.82 0.0.1 10300100ECC53700 29 031313133133 41.5 234.2 ... 154.6 62.3 32629 {'type': 'Polygon', 'coordinates': [[[497552.1... MXRA-Z29-031313133133 497552.18505859375,3379843.75,500156.25,338515... 13.6 0.0 0 https://maxar-opendata.s3.amazonaws.com/events... 2 POLYGON ((-9.02489 30.55382, -8.99837 30.55383... 2023-09-10T11:46:25Z WV02 0.82 0.0.1 10300100ECC53700 29 031313133311 41.4 234.4 ... 154.6 62.3 32629 {'type': 'Polygon', 'coordinates': [[[497612.6... MXRA-Z29-031313133311 497612.60986328125,3374843.75,500156.25,338015... 13.3 0.0 0 https://maxar-opendata.s3.amazonaws.com/events... 3 POLYGON ((-9.02435 30.50870, -8.99837 30.50871... 2023-09-10T11:46:25Z WV02 0.82 0.0.1 10300100ECC53700 29 031313133313 41.4 234.6 ... 154.6 62.3 32629 {'type': 'Polygon', 'coordinates': [[[497663.2... MXRA-Z29-031313133313 497663.26904296875,3369843.75,500156.25,337515... 13.1 0.0 0 https://maxar-opendata.s3.amazonaws.com/events... 4 POLYGON ((-9.02396 30.46358, -8.99837 30.46359... 2023-09-10T11:46:25Z WV02 0.82 0.0.1 10300100ECC53700 29 031313133331 41.4 234.8 ... 154.6 62.4 32629 {'type': 'Polygon', 'coordinates': [[[497699.8... MXRA-Z29-031313133331 497604.3701171875,3364843.75,500156.25,3370156.25 13.1 0.0 0 https://maxar-opendata.s3.amazonaws.com/events... <p>5 rows \u00d7 21 columns</p> <p>Add the footprints to the map:</p> In\u00a0[7]: Copied! <pre>m = leafmap.Map()\nm.add_gdf(gdf, layer_name=\"Footprints\", zoom_to_layer=True, info_mode=\"on_click\")\nm\n</pre> m = leafmap.Map() m.add_gdf(gdf, layer_name=\"Footprints\", zoom_to_layer=True, info_mode=\"on_click\") m Out[7]: <p>Retrieve the COG URLs for all tiles in a collection:</p> In\u00a0[8]: Copied! <pre>images = gdf[\"visual\"].tolist()\nimages[:5]\n</pre> images = gdf[\"visual\"].tolist() images[:5] Out[8]: <pre>['https://maxar-opendata.s3.amazonaws.com/events/Morocco-Earthquake-Sept-2023/ard/29/031313133131/2023-09-10/10300100ECC53700-visual.tif',\n 'https://maxar-opendata.s3.amazonaws.com/events/Morocco-Earthquake-Sept-2023/ard/29/031313133133/2023-09-10/10300100ECC53700-visual.tif',\n 'https://maxar-opendata.s3.amazonaws.com/events/Morocco-Earthquake-Sept-2023/ard/29/031313133311/2023-09-10/10300100ECC53700-visual.tif',\n 'https://maxar-opendata.s3.amazonaws.com/events/Morocco-Earthquake-Sept-2023/ard/29/031313133313/2023-09-10/10300100ECC53700-visual.tif',\n 'https://maxar-opendata.s3.amazonaws.com/events/Morocco-Earthquake-Sept-2023/ard/29/031313133331/2023-09-10/10300100ECC53700-visual.tif']</pre> <p>Download the COGs to a local directory:</p> In\u00a0[9]: Copied! <pre>leafmap.maxar_download(images[:2])\n</pre> leafmap.maxar_download(images[:2]) <pre>/media/hdd/Dropbox/git/amazon/maxar-open-data/examples/10300100ECC53700/031313133131.tif already exists. Skipping...\n/media/hdd/Dropbox/git/amazon/maxar-open-data/examples/10300100ECC53700/031313133133.tif already exists. Skipping...\n</pre> <p>Create a mosaic json file for the collection. You need to install <code>cogeo-mosaic</code> first using <code>pip install cogeo-mosaic</code>. Creating a mosaic json file might take a few minutes. Please be patient.</p> In\u00a0[10]: Copied! <pre># leafmap.create_mosaicjson(images, output='10300100ECC53700.json')\n</pre> # leafmap.create_mosaicjson(images, output='10300100ECC53700.json') <p>Make the mosaic json file available on the web, then you can add the mosaic to the map:</p> In\u00a0[11]: Copied! <pre>m = leafmap.Map(height=\"600px\")\nm.add_basemap(\"SATELLITE\")\nurl = \"https://open.gishub.org/maxar-open-data/datasets/Morocco-Earthquake-Sept-2023/10300100ECC53700.json\"\nm.add_stac_layer(url, name=\"Mosaic\")\nm.add_gdf(gdf, layer_name=\"Footprints\", info_mode=\"on_click\")\nm\n</pre> m = leafmap.Map(height=\"600px\") m.add_basemap(\"SATELLITE\") url = \"https://open.gishub.org/maxar-open-data/datasets/Morocco-Earthquake-Sept-2023/10300100ECC53700.json\" m.add_stac_layer(url, name=\"Mosaic\") m.add_gdf(gdf, layer_name=\"Footprints\", info_mode=\"on_click\") m Out[11]: <p>Retrieve the footprint of all tiles for a specific event. This might take 15+ minutes. Please be patient.</p> In\u00a0[12]: Copied! <pre># gdf = leafmap.maxar_all_items(\n#     collection_id='Morocco-Earthquake-Sept-2023',\n#     return_gdf=True,\n#     verbose=True\n#     )\n# gdf.to_file('maxar_footprints.geojson', driver='GeoJSON')\n# gdf\n</pre> # gdf = leafmap.maxar_all_items( #     collection_id='Morocco-Earthquake-Sept-2023', #     return_gdf=True, #     verbose=True #     ) # gdf.to_file('maxar_footprints.geojson', driver='GeoJSON') # gdf <p>Add the footprints to the map:</p> In\u00a0[14]: Copied! <pre>m = leafmap.Map(center=[31.35874, -8.78226], zoom=8)\nurl = \"https://raw.githubusercontent.com/opengeos/maxar-open-data/master/datasets/Morocco-Earthquake-Sept-2023_union.geojson\"\nm.add_geojson(url, layer_name=\"Footprints\", info_mode=\"on_click\")\nm\n</pre> m = leafmap.Map(center=[31.35874, -8.78226], zoom=8) url = \"https://raw.githubusercontent.com/opengeos/maxar-open-data/master/datasets/Morocco-Earthquake-Sept-2023_union.geojson\" m.add_geojson(url, layer_name=\"Footprints\", info_mode=\"on_click\") m Out[14]: <p>You can find the list of all available images at Morocco-Earthquake-Sept-2023.tsv.</p> In\u00a0[15]: Copied! <pre>gdf = leafmap.geojson_to_gdf(url)\ngdf.head()\n</pre> gdf = leafmap.geojson_to_gdf(url) gdf.head() Out[15]: datetime platform gsd ard_metadata_version catalog_id utm_zone quadkey view:off_nadir view:azimuth view:incidence_angle view:sun_azimuth view:sun_elevation proj:epsg grid:code proj:bbox tile:data_area tile:clouds_area tile:clouds_percent visual geometry 0 2018-08-31 11:25:53+00:00 WV04 0.37 0.0.1 04eddade-a2dc-4d16-8710-fb764d318766-inv 29 031313133120 25.4 121.8 61.9 139.1 62.6 32629 MXRA-Z29-031313133120 483190.3076171875,3384843.75,485156.25,3385087... 0.3 0.0 0 https://maxar-opendata.s3.amazonaws.com/events... POLYGON ((-9.17602 30.32703, -9.17603 30.32811... 1 2010-08-26 11:38:32+00:00 WV02 0.48 0.0.1 1030010006CA6400 29 120200233033 12.0 284.1 76.5 147.3 65.3 32629 MXRA-Z29-120200233033 639438.4765625,3539843.75,640156.25,3543812.25... 2.7 0.0 0 https://maxar-opendata.s3.amazonaws.com/events... POLYGON ((-7.52311 31.06177, -7.52282 31.06705... 2 2011-08-26 11:31:38+00:00 WV02 0.50 0.0.1 103001000DA1E700 29 120200322030 15.8 147.0 72.2 144.4 64.7 32629 MXRA-Z29-120200322030 672485.6567382812,3544843.75,675156.25,3546388... 4.0 0.4 11 https://maxar-opendata.s3.amazonaws.com/events... MULTIPOLYGON (((-7.16634 31.04317, -7.16631 31... 3 2012-08-29 11:54:08+00:00 WV02 0.48 0.0.1 103001001A7CAE00 29 120200220023 9.4 288.2 79.4 154.8 64.9 32629 MXRA-Z29-120200220023 508232.06948724756,3579843.75,510156.25,358154... 2.6 0.0 0 https://maxar-opendata.s3.amazonaws.com/events... POLYGON ((-8.89582 31.96387, -8.93980 31.96420... 4 2013-11-12 11:42:03+00:00 WV02 0.48 0.0.1 10300100295F5E00 29 120200222032 10.1 156.6 78.7 168.5 39.6 32629 MXRA-Z29-120200222032 514152.52685546875,3539843.75,515156.25,354183... 1.9 0.0 0 https://maxar-opendata.s3.amazonaws.com/events... POLYGON ((-8.80616 30.96769, -8.81327 30.96744... In\u00a0[16]: Copied! <pre>before = gdf[gdf[\"datetime\"] &lt; \"2023-09-10\"]\nlen(before)\n</pre> before = gdf[gdf[\"datetime\"] &lt; \"2023-09-10\"] len(before) Out[16]: <pre>226</pre> In\u00a0[17]: Copied! <pre>before.head()\n</pre> before.head() Out[17]: datetime platform gsd ard_metadata_version catalog_id utm_zone quadkey view:off_nadir view:azimuth view:incidence_angle view:sun_azimuth view:sun_elevation proj:epsg grid:code proj:bbox tile:data_area tile:clouds_area tile:clouds_percent visual geometry 0 2018-08-31 11:25:53+00:00 WV04 0.37 0.0.1 04eddade-a2dc-4d16-8710-fb764d318766-inv 29 031313133120 25.4 121.8 61.9 139.1 62.6 32629 MXRA-Z29-031313133120 483190.3076171875,3384843.75,485156.25,3385087... 0.3 0.0 0 https://maxar-opendata.s3.amazonaws.com/events... POLYGON ((-9.17602 30.32703, -9.17603 30.32811... 1 2010-08-26 11:38:32+00:00 WV02 0.48 0.0.1 1030010006CA6400 29 120200233033 12.0 284.1 76.5 147.3 65.3 32629 MXRA-Z29-120200233033 639438.4765625,3539843.75,640156.25,3543812.25... 2.7 0.0 0 https://maxar-opendata.s3.amazonaws.com/events... POLYGON ((-7.52311 31.06177, -7.52282 31.06705... 2 2011-08-26 11:31:38+00:00 WV02 0.50 0.0.1 103001000DA1E700 29 120200322030 15.8 147.0 72.2 144.4 64.7 32629 MXRA-Z29-120200322030 672485.6567382812,3544843.75,675156.25,3546388... 4.0 0.4 11 https://maxar-opendata.s3.amazonaws.com/events... MULTIPOLYGON (((-7.16634 31.04317, -7.16631 31... 3 2012-08-29 11:54:08+00:00 WV02 0.48 0.0.1 103001001A7CAE00 29 120200220023 9.4 288.2 79.4 154.8 64.9 32629 MXRA-Z29-120200220023 508232.06948724756,3579843.75,510156.25,358154... 2.6 0.0 0 https://maxar-opendata.s3.amazonaws.com/events... POLYGON ((-8.89582 31.96387, -8.93980 31.96420... 4 2013-11-12 11:42:03+00:00 WV02 0.48 0.0.1 10300100295F5E00 29 120200222032 10.1 156.6 78.7 168.5 39.6 32629 MXRA-Z29-120200222032 514152.52685546875,3539843.75,515156.25,354183... 1.9 0.0 0 https://maxar-opendata.s3.amazonaws.com/events... POLYGON ((-8.80616 30.96769, -8.81327 30.96744... In\u00a0[18]: Copied! <pre>after = gdf[gdf[\"datetime\"] &gt;= \"2023-09-10\"]\nlen(after)\n</pre> after = gdf[gdf[\"datetime\"] &gt;= \"2023-09-10\"] len(after) Out[18]: <pre>12</pre> In\u00a0[19]: Copied! <pre>after.head()\n</pre> after.head() Out[19]: datetime platform gsd ard_metadata_version catalog_id utm_zone quadkey view:off_nadir view:azimuth view:incidence_angle view:sun_azimuth view:sun_elevation proj:epsg grid:code proj:bbox tile:data_area tile:clouds_area tile:clouds_percent visual geometry 41 2023-09-10 11:46:24+00:00 WV02 0.83 0.0.1 10300100ECC53700 29 031313133131 41.5 234.2 42.0 154.6 62.3 32629 MXRA-Z29-031313133131 497536.92626953125,3384843.75,500156.25,338652... 3.2 0.0 0 https://maxar-opendata.s3.amazonaws.com/events... POLYGON ((-8.94962 30.32099, -8.94962 30.32100... 42 2023-09-10 11:46:13+00:00 WV02 0.86 0.0.1 10300100ED11EA00 29 120202003030 42.6 235.8 40.6 156.3 61.8 32629 MXRA-Z29-120202003030 554911.8041992188,3464843.75,555156.25,3466014... 0.2 0.0 0 https://maxar-opendata.s3.amazonaws.com/events... POLYGON ((-8.42230 30.99072, -8.42231 30.99033... 58 2023-09-10 11:44:16+00:00 WV02 0.62 0.0.1 10300500E4F91400 29 120202000032 30.8 309.6 54.9 154.6 61.3 32629 MXRA-Z29-120202000032 511449.89013671875,3499843.75,515156.25,350205... 6.9 0.0 0 https://maxar-opendata.s3.amazonaws.com/events... POLYGON ((-8.78141 31.43107, -8.78790 31.43212... 59 2023-09-10 11:44:26+00:00 WV02 0.64 0.0.1 10300500E4F91500 29 120202003202 32.4 305.2 53.1 154.9 61.8 32629 MXRA-Z29-120202003202 540894.1650390625,3449843.75,541899.4140625,34... 0.0 0.0 0 https://maxar-opendata.s3.amazonaws.com/events... POLYGON ((-8.44168 30.91998, -8.44655 30.92183... 60 2023-09-10 11:44:54+00:00 WV02 0.64 0.0.1 10300500E4F91700 29 120202012023 33.0 280.7 52.4 156.2 61.9 32629 MXRA-Z29-120202012023 585154.1137695312,3459843.75,590156.25,3464666... 23.2 0.0 0 https://maxar-opendata.s3.amazonaws.com/events... POLYGON ((-7.94900 31.17297, -7.95399 31.17331... In\u00a0[20]: Copied! <pre>m = leafmap.Map()\nm.add_gdf(before, layer_name=\"Before\", info_mode=\"on_click\")\nstyle_dict = {\"color\": \"red\", \"fillColor\": \"red\", \"fillOpacity\": 0.1}\nstyle_function = lambda x: style_dict\nm.add_gdf(\n    after, layer_name=\"After\", info_mode=\"on_click\", style_function=style_function\n)\nm\n</pre> m = leafmap.Map() m.add_gdf(before, layer_name=\"Before\", info_mode=\"on_click\") style_dict = {\"color\": \"red\", \"fillColor\": \"red\", \"fillOpacity\": 0.1} style_function = lambda x: style_dict m.add_gdf(     after, layer_name=\"After\", info_mode=\"on_click\", style_function=style_function ) m Out[20]:"},{"location":"pakistan_floods/","title":"Pakistan floods","text":"In\u00a0[1]: Copied! <pre># !pip install geemap\n</pre> # !pip install geemap In\u00a0[2]: Copied! <pre>import ee\nimport geemap.foliumap as geemap\n</pre> import ee import geemap.foliumap as geemap In\u00a0[3]: Copied! <pre>m = geemap.Map(center=[29.3055, 68.9062], zoom=6)\nm\n</pre> m = geemap.Map(center=[29.3055, 68.9062], zoom=6) m Out[3]: <p>In the tutorial, we will focus on Pakistan, but the code can be easily modified to visualize and analyze floods in other countries. Modify the <code>country_name</code> variable to specify the country of interest and set the date range for the flood event. In order to extract the flood extent, we also need to specify the date range for the pre-flood period.</p> In\u00a0[4]: Copied! <pre>country_name = \"Pakistan\"\npre_flood_start_date = \"2021-08-01\"\npre_flood_end_date = \"2021-09-30\"\nflood_start_date = \"2022-08-01\"\nflood_end_date = \"2022-09-30\"\n</pre> country_name = \"Pakistan\" pre_flood_start_date = \"2021-08-01\" pre_flood_end_date = \"2021-09-30\" flood_start_date = \"2022-08-01\" flood_end_date = \"2022-09-30\" In\u00a0[5]: Copied! <pre>m = geemap.Map()\n\ncountry = ee.FeatureCollection(\"USDOS/LSIB_SIMPLE/2017\").filter(\n    ee.Filter.eq(\"country_na\", country_name)\n)\n\nstyle = {\"color\": \"black\", \"fillColor\": \"00000000\"}\nm.add_layer(country.style(**style), {}, country_name)\nm.center_object(country, 5)\n\nm\n</pre> m = geemap.Map()  country = ee.FeatureCollection(\"USDOS/LSIB_SIMPLE/2017\").filter(     ee.Filter.eq(\"country_na\", country_name) )  style = {\"color\": \"black\", \"fillColor\": \"00000000\"} m.add_layer(country.style(**style), {}, country_name) m.center_object(country, 5)  m Out[5]: In\u00a0[6]: Copied! <pre>m = geemap.Map()\n\nlandsat_col_2021 = (\n    ee.ImageCollection(\"LANDSAT/LC08/C02/T1\")\n    .filterDate(pre_flood_start_date, pre_flood_end_date)\n    .filterBounds(country)\n)\nlandsat_2021 = ee.Algorithms.Landsat.simpleComposite(landsat_col_2021).clipToCollection(\n    country\n)\n\nvis_params = {\"bands\": [\"B6\", \"B5\", \"B4\"], \"max\": 128}\nm.add_layer(landsat_2021, vis_params, \"Landsat 2021\")\n</pre> m = geemap.Map()  landsat_col_2021 = (     ee.ImageCollection(\"LANDSAT/LC08/C02/T1\")     .filterDate(pre_flood_start_date, pre_flood_end_date)     .filterBounds(country) ) landsat_2021 = ee.Algorithms.Landsat.simpleComposite(landsat_col_2021).clipToCollection(     country )  vis_params = {\"bands\": [\"B6\", \"B5\", \"B4\"], \"max\": 128} m.add_layer(landsat_2021, vis_params, \"Landsat 2021\") <p>Create a Landsat 8 composite for the flood period (August 1 to September 30, 2022).</p> In\u00a0[7]: Copied! <pre>landsat_col_2022 = (\n    ee.ImageCollection(\"LANDSAT/LC08/C02/T1\")\n    .filterDate(flood_start_date, flood_end_date)\n    .filterBounds(country)\n)\nlandsat_2022 = ee.Algorithms.Landsat.simpleComposite(landsat_col_2022).clipToCollection(\n    country\n)\n\nm.add_layer(landsat_2022, vis_params, \"Landsat 2022\")\nm.center_object(country, 5)\nm\n</pre> landsat_col_2022 = (     ee.ImageCollection(\"LANDSAT/LC08/C02/T1\")     .filterDate(flood_start_date, flood_end_date)     .filterBounds(country) ) landsat_2022 = ee.Algorithms.Landsat.simpleComposite(landsat_col_2022).clipToCollection(     country )  m.add_layer(landsat_2022, vis_params, \"Landsat 2022\") m.center_object(country, 5) m Out[7]: In\u00a0[8]: Copied! <pre>m = geemap.Map()\nm.setCenter(68.4338, 26.4213, 7)\n\nleft_layer = geemap.ee_tile_layer(landsat_2021, vis_params, \"Landsat 2021\")\nright_layer = geemap.ee_tile_layer(landsat_2022, vis_params, \"Landsat 2022\")\n\nm.split_map(\n    left_layer, right_layer, left_label=\"Landsat 2021\", right_label=\"Landsat 2022\"\n)\nm.add_layer(country.style(**style), {}, country_name)\nm\n</pre> m = geemap.Map() m.setCenter(68.4338, 26.4213, 7)  left_layer = geemap.ee_tile_layer(landsat_2021, vis_params, \"Landsat 2021\") right_layer = geemap.ee_tile_layer(landsat_2022, vis_params, \"Landsat 2022\")  m.split_map(     left_layer, right_layer, left_label=\"Landsat 2021\", right_label=\"Landsat 2022\" ) m.add_layer(country.style(**style), {}, country_name) m Out[8]: In\u00a0[9]: Copied! <pre>ndwi_2021 = landsat_2021.normalizedDifference([\"B3\", \"B5\"]).rename(\"NDWI\")\nndwi_2022 = landsat_2022.normalizedDifference([\"B3\", \"B5\"]).rename(\"NDWI\")\n</pre> ndwi_2021 = landsat_2021.normalizedDifference([\"B3\", \"B5\"]).rename(\"NDWI\") ndwi_2022 = landsat_2022.normalizedDifference([\"B3\", \"B5\"]).rename(\"NDWI\") <p>Compute the NDWI layers for the pre-flood and flood periods side by side.</p> In\u00a0[10]: Copied! <pre>m = geemap.Map()\nm.setCenter(68.4338, 26.4213, 7)\n\nndwi_vis = {\"min\": -1, \"max\": 1, \"palette\": \"ndwi\"}\n\nleft_layer = geemap.ee_tile_layer(ndwi_2021, ndwi_vis, \"NDWI 2021\")\nright_layer = geemap.ee_tile_layer(ndwi_2022, ndwi_vis, \"NDWI 2022\")\n\nm.split_map(left_layer, right_layer, left_label=\"NDWI 2021\", right_label=\"NDWI 2022\")\nm.add_layer(country.style(**style), {}, country_name)\nm\n</pre> m = geemap.Map() m.setCenter(68.4338, 26.4213, 7)  ndwi_vis = {\"min\": -1, \"max\": 1, \"palette\": \"ndwi\"}  left_layer = geemap.ee_tile_layer(ndwi_2021, ndwi_vis, \"NDWI 2021\") right_layer = geemap.ee_tile_layer(ndwi_2022, ndwi_vis, \"NDWI 2022\")  m.split_map(left_layer, right_layer, left_label=\"NDWI 2021\", right_label=\"NDWI 2022\") m.add_layer(country.style(**style), {}, country_name) m Out[10]: In\u00a0[11]: Copied! <pre>threshold = 0.1\nwater_2021 = ndwi_2021.gt(threshold)\nwater_2022 = ndwi_2022.gt(threshold)\n</pre> threshold = 0.1 water_2021 = ndwi_2021.gt(threshold) water_2022 = ndwi_2022.gt(threshold) <p>Combine the pre-flood and surface water extent side by side.</p> In\u00a0[12]: Copied! <pre>m = geemap.Map()\nm.setCenter(68.4338, 26.4213, 7)\n\nm.add_layer(landsat_2021, vis_params, \"Landsat 2021\", False)\nm.add_layer(landsat_2022, vis_params, \"Landsat 2022\", False)\n\nleft_layer = geemap.ee_tile_layer(\n    water_2021.selfMask(), {\"palette\": \"blue\"}, \"Water 2021\"\n)\nright_layer = geemap.ee_tile_layer(\n    water_2022.selfMask(), {\"palette\": \"red\"}, \"Water 2022\"\n)\n\nm.split_map(left_layer, right_layer, left_label=\"Water 2021\", right_label=\"Water 2022\")\nm.add_layer(country.style(**style), {}, country_name)\nm\n</pre> m = geemap.Map() m.setCenter(68.4338, 26.4213, 7)  m.add_layer(landsat_2021, vis_params, \"Landsat 2021\", False) m.add_layer(landsat_2022, vis_params, \"Landsat 2022\", False)  left_layer = geemap.ee_tile_layer(     water_2021.selfMask(), {\"palette\": \"blue\"}, \"Water 2021\" ) right_layer = geemap.ee_tile_layer(     water_2022.selfMask(), {\"palette\": \"red\"}, \"Water 2022\" )  m.split_map(left_layer, right_layer, left_label=\"Water 2021\", right_label=\"Water 2022\") m.add_layer(country.style(**style), {}, country_name) m Out[12]: In\u00a0[13]: Copied! <pre>flood_extent = water_2022.subtract(water_2021).gt(0).selfMask()\n</pre> flood_extent = water_2022.subtract(water_2021).gt(0).selfMask() <p>Add the flood extent layer to the map.</p> In\u00a0[14]: Copied! <pre>m = geemap.Map()\nm.setCenter(68.4338, 26.4213, 7)\n\nm.add_layer(landsat_2021, vis_params, \"Landsat 2021\", False)\nm.add_layer(landsat_2022, vis_params, \"Landsat 2022\", False)\n\nleft_layer = geemap.ee_tile_layer(\n    water_2021.selfMask(), {\"palette\": \"blue\"}, \"Water 2021\"\n)\nright_layer = geemap.ee_tile_layer(\n    water_2022.selfMask(), {\"palette\": \"red\"}, \"Water 2022\"\n)\n\nm.split_map(left_layer, right_layer, left_label=\"Water 2021\", right_label=\"Water 2022\")\n\nm.add_layer(flood_extent, {\"palette\": \"cyan\"}, \"Flood Extent\")\nm.add_layer(country.style(**style), {}, country_name)\nm\n</pre> m = geemap.Map() m.setCenter(68.4338, 26.4213, 7)  m.add_layer(landsat_2021, vis_params, \"Landsat 2021\", False) m.add_layer(landsat_2022, vis_params, \"Landsat 2022\", False)  left_layer = geemap.ee_tile_layer(     water_2021.selfMask(), {\"palette\": \"blue\"}, \"Water 2021\" ) right_layer = geemap.ee_tile_layer(     water_2022.selfMask(), {\"palette\": \"red\"}, \"Water 2022\" )  m.split_map(left_layer, right_layer, left_label=\"Water 2021\", right_label=\"Water 2022\")  m.add_layer(flood_extent, {\"palette\": \"cyan\"}, \"Flood Extent\") m.add_layer(country.style(**style), {}, country_name) m Out[14]: In\u00a0[15]: Copied! <pre>area_2021 = geemap.zonal_stats(\n    water_2021.selfMask(), country, scale=1000, stat_type=\"SUM\", return_fc=True\n)\ngeemap.ee_to_df(area_2021)\n</pre> area_2021 = geemap.zonal_stats(     water_2021.selfMask(), country, scale=1000, stat_type=\"SUM\", return_fc=True ) geemap.ee_to_df(area_2021) <pre>Computing statistics ...\n</pre> Out[15]: abbreviati country_co country_na sum wld_rgn 0 Pak. PK Pakistan 4205.678431 S Asia In\u00a0[16]: Copied! <pre>area_2022 = geemap.zonal_stats(\n    water_2022.selfMask(), country, scale=1000, stat_type=\"SUM\", return_fc=True\n)\ngeemap.ee_to_df(area_2022)\n</pre> area_2022 = geemap.zonal_stats(     water_2022.selfMask(), country, scale=1000, stat_type=\"SUM\", return_fc=True ) geemap.ee_to_df(area_2022) <pre>Computing statistics ...\n</pre> Out[16]: abbreviati country_co country_na sum wld_rgn 0 Pak. PK Pakistan 13145.027451 S Asia In\u00a0[17]: Copied! <pre>flood_area = geemap.zonal_stats(\n    flood_extent.selfMask(), country, scale=1000, stat_type=\"SUM\", return_fc=True\n)\ngeemap.ee_to_df(flood_area)\n</pre> flood_area = geemap.zonal_stats(     flood_extent.selfMask(), country, scale=1000, stat_type=\"SUM\", return_fc=True ) geemap.ee_to_df(flood_area) <pre>Computing statistics ...\n</pre> Out[17]: abbreviati country_co country_na sum wld_rgn 0 Pak. PK Pakistan 11065.72549 S Asia <p>The total area of the flood extent is 11,065 square kilometers based on Landsat 8 images.</p> In\u00a0[18]: Copied! <pre>s1_col_2021 = (\n    ee.ImageCollection(\"COPERNICUS/S1_GRD\")\n    .filter(ee.Filter.listContains(\"transmitterReceiverPolarisation\", \"VV\"))\n    .filter(ee.Filter.eq(\"instrumentMode\", \"IW\"))\n    .filter(ee.Filter.eq(\"orbitProperties_pass\", \"ASCENDING\"))\n    .filterDate(pre_flood_start_date, pre_flood_end_date)\n    .filterBounds(country)\n    .select(\"VV\")\n)\n</pre> s1_col_2021 = (     ee.ImageCollection(\"COPERNICUS/S1_GRD\")     .filter(ee.Filter.listContains(\"transmitterReceiverPolarisation\", \"VV\"))     .filter(ee.Filter.eq(\"instrumentMode\", \"IW\"))     .filter(ee.Filter.eq(\"orbitProperties_pass\", \"ASCENDING\"))     .filterDate(pre_flood_start_date, pre_flood_end_date)     .filterBounds(country)     .select(\"VV\") ) <p>247 Sentinel-1 IW mode images are available for the flood period.</p> In\u00a0[19]: Copied! <pre># s1_col_2021\n</pre> # s1_col_2021 <p>Create the Sentinel-1 image collection for the flood period.</p> In\u00a0[20]: Copied! <pre>s1_col_2022 = (\n    ee.ImageCollection(\"COPERNICUS/S1_GRD\")\n    .filter(ee.Filter.listContains(\"transmitterReceiverPolarisation\", \"VV\"))\n    .filter(ee.Filter.eq(\"instrumentMode\", \"IW\"))\n    .filter(ee.Filter.eq(\"orbitProperties_pass\", \"ASCENDING\"))\n    .filterDate(flood_start_date, flood_end_date)\n    .filterBounds(country)\n    .select(\"VV\")\n)\n</pre> s1_col_2022 = (     ee.ImageCollection(\"COPERNICUS/S1_GRD\")     .filter(ee.Filter.listContains(\"transmitterReceiverPolarisation\", \"VV\"))     .filter(ee.Filter.eq(\"instrumentMode\", \"IW\"))     .filter(ee.Filter.eq(\"orbitProperties_pass\", \"ASCENDING\"))     .filterDate(flood_start_date, flood_end_date)     .filterBounds(country)     .select(\"VV\") ) <p>250 Sentinel-1 IW mode images are available for the flood period.</p> In\u00a0[21]: Copied! <pre># s1_col_2022\n</pre> # s1_col_2022 <p>Create Sentinel-1 SAR composites for the pre-flood and flood periods.</p> In\u00a0[22]: Copied! <pre>m = geemap.Map()\nm.add_basemap(\"HYBRID\")\nsar_2021 = s1_col_2021.reduce(ee.Reducer.percentile([20])).clipToCollection(country)\nsar_2022 = s1_col_2022.reduce(ee.Reducer.percentile([20])).clipToCollection(country)\nm.add_layer(sar_2021, {\"min\": -25, \"max\": -5}, \"SAR 2021\")\nm.add_layer(sar_2022, {\"min\": -25, \"max\": -5}, \"SAR 2022\")\nm.center_object(country, 5)\nm\n</pre> m = geemap.Map() m.add_basemap(\"HYBRID\") sar_2021 = s1_col_2021.reduce(ee.Reducer.percentile([20])).clipToCollection(country) sar_2022 = s1_col_2022.reduce(ee.Reducer.percentile([20])).clipToCollection(country) m.add_layer(sar_2021, {\"min\": -25, \"max\": -5}, \"SAR 2021\") m.add_layer(sar_2022, {\"min\": -25, \"max\": -5}, \"SAR 2022\") m.center_object(country, 5) m Out[22]: In\u00a0[23]: Copied! <pre>col_2021 = s1_col_2021.map(lambda img: img.focal_median(100, \"circle\", \"meters\"))\ncol_2022 = s1_col_2022.map(lambda img: img.focal_median(100, \"circle\", \"meters\"))\n</pre> col_2021 = s1_col_2021.map(lambda img: img.focal_median(100, \"circle\", \"meters\")) col_2022 = s1_col_2022.map(lambda img: img.focal_median(100, \"circle\", \"meters\")) In\u00a0[24]: Copied! <pre>m = geemap.Map()\nm.add_basemap(\"HYBRID\")\nsar_2021 = col_2021.reduce(ee.Reducer.percentile([20])).clipToCollection(country)\nsar_2022 = col_2022.reduce(ee.Reducer.percentile([20])).clipToCollection(country)\nm.add_layer(sar_2021, {\"min\": -25, \"max\": -5}, \"SAR 2021\")\nm.add_layer(sar_2022, {\"min\": -25, \"max\": -5}, \"SAR 2022\")\nm.center_object(country, 5)\nm\n</pre> m = geemap.Map() m.add_basemap(\"HYBRID\") sar_2021 = col_2021.reduce(ee.Reducer.percentile([20])).clipToCollection(country) sar_2022 = col_2022.reduce(ee.Reducer.percentile([20])).clipToCollection(country) m.add_layer(sar_2021, {\"min\": -25, \"max\": -5}, \"SAR 2021\") m.add_layer(sar_2022, {\"min\": -25, \"max\": -5}, \"SAR 2022\") m.center_object(country, 5) m Out[24]: In\u00a0[25]: Copied! <pre>m = geemap.Map()\nm.setCenter(68.4338, 26.4213, 7)\n\nleft_layer = geemap.ee_tile_layer(sar_2021, {\"min\": -25, \"max\": -5}, \"SAR 2021\")\nright_layer = geemap.ee_tile_layer(sar_2022, {\"min\": -25, \"max\": -5}, \"SAR 2022\")\n\nm.split_map(\n    left_layer, right_layer, left_label=\"Sentinel-1 2021\", right_label=\"Sentinel-1 2022\"\n)\nm.add_layer(country.style(**style), {}, country_name)\nm\n</pre> m = geemap.Map() m.setCenter(68.4338, 26.4213, 7)  left_layer = geemap.ee_tile_layer(sar_2021, {\"min\": -25, \"max\": -5}, \"SAR 2021\") right_layer = geemap.ee_tile_layer(sar_2022, {\"min\": -25, \"max\": -5}, \"SAR 2022\")  m.split_map(     left_layer, right_layer, left_label=\"Sentinel-1 2021\", right_label=\"Sentinel-1 2022\" ) m.add_layer(country.style(**style), {}, country_name) m Out[25]: In\u00a0[26]: Copied! <pre>threshold = -18\nwater_2021 = sar_2021.lt(threshold)\nwater_2022 = sar_2022.lt(threshold)\n</pre> threshold = -18 water_2021 = sar_2021.lt(threshold) water_2022 = sar_2022.lt(threshold) <p>Create a split-view map to compare the pre-flood and flood water extent side by side.</p> In\u00a0[27]: Copied! <pre>m = geemap.Map()\nm.setCenter(68.4338, 26.4213, 7)\n\nm.add_layer(sar_2021, {\"min\": -25, \"max\": -5}, \"SAR 2021\")\nm.add_layer(sar_2022, {\"min\": -25, \"max\": -5}, \"SAR 2022\")\n\nleft_layer = geemap.ee_tile_layer(\n    water_2021.selfMask(), {\"palette\": \"blue\"}, \"Water 2021\"\n)\nright_layer = geemap.ee_tile_layer(\n    water_2022.selfMask(), {\"palette\": \"red\"}, \"Water 2022\"\n)\n\nm.split_map(left_layer, right_layer, left_label=\"Water 2021\", right_label=\"Water 2022\")\nm.add_layer(country.style(**style), {}, country_name)\nm\n</pre> m = geemap.Map() m.setCenter(68.4338, 26.4213, 7)  m.add_layer(sar_2021, {\"min\": -25, \"max\": -5}, \"SAR 2021\") m.add_layer(sar_2022, {\"min\": -25, \"max\": -5}, \"SAR 2022\")  left_layer = geemap.ee_tile_layer(     water_2021.selfMask(), {\"palette\": \"blue\"}, \"Water 2021\" ) right_layer = geemap.ee_tile_layer(     water_2022.selfMask(), {\"palette\": \"red\"}, \"Water 2022\" )  m.split_map(left_layer, right_layer, left_label=\"Water 2021\", right_label=\"Water 2022\") m.add_layer(country.style(**style), {}, country_name) m Out[27]: In\u00a0[28]: Copied! <pre>flood_extent = water_2022.subtract(water_2021).gt(0).selfMask()\n</pre> flood_extent = water_2022.subtract(water_2021).gt(0).selfMask() <p>The flood extent is the difference between the flood water extent and the pre-flood water extent. In other words, pixels identified as water in the flood period but not in the pre-flood period are considered as flooded pixels, which are shown in cyan.</p> In\u00a0[29]: Copied! <pre>m = geemap.Map()\nm.setCenter(68.4338, 26.4213, 7)\n\nm.add_layer(sar_2021, {\"min\": -25, \"max\": -5}, \"SAR 2021\")\nm.add_layer(sar_2022, {\"min\": -25, \"max\": -5}, \"SAR 2022\")\n\nleft_layer = geemap.ee_tile_layer(\n    water_2021.selfMask(), {\"palette\": \"blue\"}, \"Water 2021\"\n)\nright_layer = geemap.ee_tile_layer(\n    water_2022.selfMask(), {\"palette\": \"red\"}, \"Water 2022\"\n)\n\nm.split_map(left_layer, right_layer, left_label=\"Water 2021\", right_label=\"Water 2022\")\n\nm.add_layer(flood_extent, {\"palette\": \"cyan\"}, \"Flood Extent\")\nm.add_layer(country.style(**style), {}, country_name)\nm\n</pre> m = geemap.Map() m.setCenter(68.4338, 26.4213, 7)  m.add_layer(sar_2021, {\"min\": -25, \"max\": -5}, \"SAR 2021\") m.add_layer(sar_2022, {\"min\": -25, \"max\": -5}, \"SAR 2022\")  left_layer = geemap.ee_tile_layer(     water_2021.selfMask(), {\"palette\": \"blue\"}, \"Water 2021\" ) right_layer = geemap.ee_tile_layer(     water_2022.selfMask(), {\"palette\": \"red\"}, \"Water 2022\" )  m.split_map(left_layer, right_layer, left_label=\"Water 2021\", right_label=\"Water 2022\")  m.add_layer(flood_extent, {\"palette\": \"cyan\"}, \"Flood Extent\") m.add_layer(country.style(**style), {}, country_name) m Out[29]: In\u00a0[30]: Copied! <pre>area_2021 = geemap.zonal_stats(\n    water_2021.selfMask(), country, scale=1000, stat_type=\"SUM\", return_fc=True\n)\ngeemap.ee_to_df(area_2021)\n</pre> area_2021 = geemap.zonal_stats(     water_2021.selfMask(), country, scale=1000, stat_type=\"SUM\", return_fc=True ) geemap.ee_to_df(area_2021) <pre>Computing statistics ...\n</pre> Out[30]: abbreviati country_co country_na sum wld_rgn 0 Pak. PK Pakistan 68949.458824 S Asia In\u00a0[31]: Copied! <pre>area_2022 = geemap.zonal_stats(\n    water_2022.selfMask(), country, scale=1000, stat_type=\"SUM\", return_fc=True\n)\ngeemap.ee_to_df(area_2022)\n</pre> area_2022 = geemap.zonal_stats(     water_2022.selfMask(), country, scale=1000, stat_type=\"SUM\", return_fc=True ) geemap.ee_to_df(area_2022) <pre>Computing statistics ...\n</pre> Out[31]: abbreviati country_co country_na sum wld_rgn 0 Pak. PK Pakistan 59224.121569 S Asia In\u00a0[32]: Copied! <pre>flood_area = geemap.zonal_stats(\n    flood_extent.selfMask(), country, scale=1000, stat_type=\"SUM\", return_fc=True\n)\ngeemap.ee_to_df(flood_area)\n</pre> flood_area = geemap.zonal_stats(     flood_extent.selfMask(), country, scale=1000, stat_type=\"SUM\", return_fc=True ) geemap.ee_to_df(flood_area) <pre>Computing statistics ...\n</pre> Out[32]: abbreviati country_co country_na sum wld_rgn 0 Pak. PK Pakistan 12263.835294 S Asia <p>The total area of the flood extent is 12,263 square kilometers based on Sentinel-1 SAR images.</p>"},{"location":"pakistan_floods/#visualization-and-analysis-of-pakistan-floods-2022-using-earth-engine-and-geemap","title":"Visualization and Analysis of Pakistan Floods 2022 Using Earth Engine and Geemap\u00b6","text":""},{"location":"pakistan_floods/#introduction","title":"Introduction\u00b6","text":"<p>From 14 June to October 2022, floods in Pakistan killed 1,739 people, and caused 3.2 trillion Pakistani Rupees (14.9 billion US Dollars) of damage and 3.3 trillion Pakistani Rupees (15.2 billion US Dollars) of economic losses. The flooding was the world's deadliest flood since the 2020 South Asian floods and described as the worst in the country's history. On 25 August 2022, Pakistan declared a state of emergency because of the flooding. See the Wikipedia page for more information about the 2022 Pakistan floods.</p>"},{"location":"pakistan_floods/#requirements","title":"Requirements\u00b6","text":"<p>To follow this tutorial, you must first sign up for a Google Earth Engine account. Earth Engine is a cloud computing platform with a multi-petabyte catalog of satellite imagery and geospatial datasets. It is free for noncommercial use. To authenticate the Earth Engine Python API, see instructions here.</p> <p>In this tutorial, we will use the geemap Python package to visualize and analyze the Pakistan floods. Geemap enables users to analyze and visualize Earth Engine datasets interactively within a Jupyter-based environment with minimal coding. To learn more about geemap, check out https://geemap.org.</p>"},{"location":"pakistan_floods/#installation","title":"Installation\u00b6","text":"<p>Uncomment the following line to install geemap if needed.</p>"},{"location":"pakistan_floods/#import-libraries","title":"Import libraries\u00b6","text":"<p>Import the earthengine-api and geemap.</p>"},{"location":"pakistan_floods/#create-an-interactive-map","title":"Create an interactive map\u00b6","text":"<p>Specify the center point <code>[lat, lon]</code> and zoom level of the map.</p>"},{"location":"pakistan_floods/#search-datasets","title":"Search datasets\u00b6","text":"<p>Click on the globe icon in the top left corner of the map to open the search panel. Select the <code>data</code> tab and enter a keyword to search for datasets, e.g., <code>countries</code>. Press <code>Enter</code> to search. The search results will populate the dropdown list. Select the dataset you want to add to the map from the dropdown list, such as the <code>LSIB 2017: Large Scale International Boundary Polygons, Simplified</code>. Click on the <code>import</code> button to add a new code cell in Jupyter Notebook. Note that Google Colab and JupyterLab do not support creating new code cells programmatically. You will need to manually add a new code cell and copy the data sample code to the new cell.</p>"},{"location":"pakistan_floods/#visualize-datasets","title":"Visualize datasets\u00b6","text":"<p>Specify the country of interest and filter the dataset by the country name.</p>"},{"location":"pakistan_floods/#create-landsat-composites","title":"Create Landsat composites\u00b6","text":"<p>Create a Landsat 8 composite for the pre-flood period (August 1 to September 30, 2021) using the USGS Landsat 8 Collection 2 Tier 1 Raw Scenes.</p>"},{"location":"pakistan_floods/#compare-landsat-composites-side-by-side","title":"Compare Landsat composites side by side\u00b6","text":"<p>Combine the pre-flood and flood composites side by side.</p>"},{"location":"pakistan_floods/#compute-normalized-difference-water-index-ndwi","title":"Compute Normalized Difference Water Index (NDWI)\u00b6","text":"<p>The Normalized Difference Water Index (NDWI) is a commonly used index for detecting water bodies. It is calculated as follows:</p> <p>$$NDWI = \\frac{Green - NIR}{Green + NIR}$$</p> <p>where Green is the green band and NIR is the near-infrared band. The NDWI values range from -1 to 1. The NDWI values are usually thresholded to a positive number (e.g., 0.1-0.3) to identify water bodies.</p> <p>Landsat 8 imagery has 11 spectral bands. The Landsat 8 NDWI is calculated using the green (<code>B3</code>) and NIR (<code>B5</code>) bands.</p> <p></p>"},{"location":"pakistan_floods/#extract-landsat-water-extent","title":"Extract Landsat water extent\u00b6","text":"<p>To extract the water extent, we need to convert the NDWI images to binary images using a threshold value. The threshold value is usually set to 0.1 to 0.3. The smaller the threshold value, the more water bodies will be detected, which may increase the false positive rate. The larger the threshold value, the fewer water bodies will be detected, which may increase the false negative rate.</p>"},{"location":"pakistan_floods/#extract-landsat-flood-extent","title":"Extract Landsat flood extent\u00b6","text":"<p>To extract the flood extent, we need to subtract the pre-flood water extent from the flood water extent. The flood extent is the difference between the flood water extent and the pre-flood water extent. In other words, pixels identified as water in the flood period but not in the pre-flood period are considered as flooded pixels. The <code>selfMask()</code> method is used to mask out the no-data pixels.</p>"},{"location":"pakistan_floods/#calculate-landsat-flood-area","title":"Calculate Landsat flood area\u00b6","text":"<p>To calculate the flood area, we can use the <code>geemap.zonal_stats()</code> function. The required input parameters are the flood extent layer and the country boundary layer. The <code>scale</code> parameter can be set to <code>1000</code> to specify the spatial resolution of image to be used for calculating the zonal statistics. The <code>stats_type</code> parameter can be set to <code>SUM</code> to calculate the total area of the flood extent in square kilometers. Set <code>return_fc=True</code> to return the zonal statistics as an <code>ee.FeatureCollection</code> object, which can be converted to a Pandas dataframe.</p>"},{"location":"pakistan_floods/#create-sentinel-1-sar-composites","title":"Create Sentinel-1 SAR composites\u00b6","text":"<p>Besides Landsat, we can also use Sentinel-1 Synthetic Aperture Radar (SAR) data to extract flood extent. Radar can collect signals in different polarizations, by controlling the analyzed polarization in both the transmit and receive paths. Signals emitted in vertical (V) and received in horizontal (H) polarization would be indicated by a VH. Alternatively, a signal that was emitted in horizontal (H) and received in horizontal (H) would be indicated by HH, and so on. Examining the signal strength from these different polarizations carries information about the structure of the imaged surface. Rough surface scattering, such as that caused by bare soil or water, is most sensitive to VV scattering. Therefore, VV polarization is often used to detect water bodies.</p> <p>Sentinel-1 operates in four exclusive acquisition modes:</p> <ul> <li>Stripmap (SM)</li> <li>Interferometric Wide swath (IW)</li> <li>Extra-Wide swath (EW)</li> <li>Wave mode (WV)</li> </ul> <p>The Interferometric Wide swath (IW) mode allows combining a large swath width (250 km) with a moderate geometric resolution (5 m by 20 m). The IW mode is the default acquisition mode over land. In this tutorial, we will use Sentinel-1 IW mode data to extract flood extent.</p> <p>The Sentinel-1 SAR data are available from 2014 to present. Let's filter the <code>COPERNICUS/S1_GRD</code> dataset by the date range and location.</p>"},{"location":"pakistan_floods/#apply-speckle-filtering","title":"Apply speckle filtering\u00b6","text":"<p>Speckle, appearing in synthetic aperture radar (SAR) images as granular noise, is due to the interference of waves reflected from many elementary scatterers. Speckle in SAR images complicates the image interpretation problem by reducing the effectiveness of image segmentation and classification (Lee et al., 1994). Therefore, speckle filtering is often applied to SAR images to reduce the speckle noise. In this example, we apply a morphological speckle filter to the Sentinel-1 SAR images. The morphological speckle filter is a non-linear filter that uses the median value of a pixel and its neighboring pixels to replace the pixel value. The kernel size is set to 100 meters.</p>"},{"location":"pakistan_floods/#compare-sentinel-1-sar-composites-side-by-side","title":"Compare Sentinel-1 SAR composites side by side\u00b6","text":"<p>Create a split-view map to compare the pre-flood and flood SAR composites side by side.</p>"},{"location":"pakistan_floods/#extract-sar-water-extent","title":"Extract SAR water extent\u00b6","text":"<p>Water usually appears dark in SAR images because radar waves are reflected differently by different surfaces. Water is a smooth, flat surface that does not reflect radar waves very well, so it appears dark in SAR images. Thresholding SAR imagery is one of the most widely used approaches to delineate water extent for its effectiveness and efficiency (Liang and Liu, 2020). Thresholding methods can be generally divided into two categories: global and local. Global thresholding methods use a single threshold value to segment the entire image. Local thresholding methods use a different threshold value for each pixel. In this example, we use a global thresholding method to extract the water extent. The threshold value is set to -18 dB.</p>"},{"location":"pakistan_floods/#extract-sar-flood-extent","title":"Extract SAR flood extent\u00b6","text":"<p>Similar to the Landsat approach, we can subtract the pre-flood water extent from the flood water extent to extract the flood extent.</p>"},{"location":"pakistan_floods/#calculate-sar-flood-area","title":"Calculate SAR flood area\u00b6","text":""},{"location":"template/","title":"Template","text":"In\u00a0[\u00a0]: Copied! <pre># !pip install leafmap\n</pre> # !pip install leafmap In\u00a0[\u00a0]: Copied! <pre>\n</pre>"}]}